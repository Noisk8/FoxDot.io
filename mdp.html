<!DOCTYPE html>

<html lang="en" class="">

<head>

      <meta charset="UTF-8"/>
      <title> Metodos de patrones </title>
      <meta name="FoxDot | Livecoding"/>
      <link rel="stylesheet" type="text/css" href="css/..."/>
      <link rel="stylesheet" type="text/css" href="css/..."/>
    <link rel="stylesheet" type="text/css" href="css/normalize.css" />
		<link rel="stylesheet" type="text/css" href="css/demo.css" />
		<link rel="stylesheet" type="text/css" href="css/style-tsula.css" />

      <script> </script>

</head>
    
     <div class="margenuno">
      <heaheader  >
         <a href="index.html" ><h1> </h1></a>
       
           <h2 >Foxdot / Renardo </h2>
   
   
   </heaheader>
    </div>

<body class="fondo">
<div class="margenuno">
    <h2> Metodos de patrones</h2>

                                <p>Esta es una lista no documentada de m茅todos que pueden ser usados con objetos Pattern.</p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                              
    <h3>shuffle(n=1)</h3>

                                <p>Devuelve el patr贸n con su contenido en un orden aleatorio y n es el n煤mero de permutaciones:</p>

                                <p><code># Una sola permutaci贸n de shuffle</code></p>
                                <p><code>print(P[0, 1, 2, 3].shuffle())</code></p>
                                <p><code>P[0, 3, 2, 1]</code></p>
                                <p><code># Dos permutaciones</code></p>
                                <p><code>print(P[0, 1, 2, 3].shuffle(2))</code></p>
                                <p><code>P[3, 1, 2, 0, 2, 1, 3, 0]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                               
    <h3> reverese()</h3>

                                <p>Devuelve el patr贸n con su contenido en orden inverso. Los patrones / grupos anidados son *no* invertidos. Use <code>Pattern.mirror </code>para obtener ese comportamiento:</p>

                                <p><code># Invierte el orden</code></p>
                                <p><code>P[0, 1, 2, 3].reverse()</code></p>
                                <p><code>P[3, 2, 1, 0]</code></p>
                                <p><code># El patr贸n anidado no se invierte cuando se usa "reverse"</code></p>
                                <p><code>P[[0, 4], 3, 2, 1].reverse()</code></p>
                                <p><code>P[1, 2, 3, P[0, 4]]</code></p>
                                <p><code># Usando mirror *does* reverse the nested patron</code></p>
                                <p><code>P[[0, 4], 3, 2, 1].mirror()</code></p>
                                <p><code>P[1, 2, 3, P[4, 0]]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                               
    <h3>mirror()</h3>

                                <p>Devuelve un patr贸n con su contenido en orden inverso, incluyendo patrones y grupos anidados:</p>

                                <p><code># Invierte el orden</code></p>
                                <p><code>P[3, 2, 1, 0]</code></p>
                                <p><code># Invertir patrones anidados y grupos</code></p>
                                <p><code>P[[0, 1], 2, 3, (4, 5)].mirror()</code></p>
                                <p><code>P[P(5, 4), 3, 2, P[1, 0]]</code></p>

                                   <hr style= "border-color: #4e7c5c; width:90%">
                               
    <h3>sort(*args, **kwargs)</h3>
                                <p>Devuelve un patr贸n con los valores ordenados. Los args y **kwargs son los que se suministran a la funci贸n ordenada integrada de Python pero esto devuelve un Patr贸n en lugar de una lista.</p>
                                <p><code># Ordenar en orden ascendente</code></p>
                                <p><code>print(P[1, 3, 2, 0].sort())</code></p>
                                <p><code>P[0, 1, 2, 3]</code></p>
                                <p><code># Ordenar por longitud del art铆culo</code></p>
                                <p><code>print(P[(1, 2), (3,), (4, 5, 6, 7), (8, 9, 10)].sort(key=lambda x: len(x)))</code></p>
                                <p><code>P[P(3), P(1, 2), P(8, 9, 10), P(4, 5, 6, 7)]</code></p>

                                   <hr style= "border-color: #4e7c5c; width:90%">
                               
    <h3>stutter(n=2)</h3>
                                <p>Devuelve un nuevo patr贸n con cada valor repetido n n煤mero de veces. Si n es un patr贸n en s铆 mismo, entonces cada valor se repite por el n煤mero en el mismo 铆ndice en el patr贸n dado.</p>


                                <p><code># Tartamudean cada valor 3 veces</code></p>
                                <p><code>print(P[0, 1, 2, 3].stutter(3))</code></p>
                                <p><code>P[0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3]</code></p>
                                <p><code># Tartamudea cada dos valores por dos</code></p>
                                <p><code>print(P[0, 1, 2, 3].stutter([1, 2]))</code></p>
                                <p><code>P[0, 1, 1, 2, 3, 3]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                               
    <h3>arp(seq)</h3>

                                <p>Devuelve un nuevo patr贸n con cada elemento repetido len(seq) veces e incrementado por los valores en seq. til para arpegiar.</p>

                                <p><code># Tartamudea de 2 en 2 y a帽ade 4 a cada segundo de valor.</code></p>
                                <p><code>print(P[0, 1, 2, 3].arp([0, 4]))</code></p>
                                <p><code>P[0, 4, 1, 5, 2, 6, 3, 7]</code></p>


                                   <hr style= "border-color: #4e7c5c; width:90%">
                               
    <h3>splice(seq, *seqs)</h3>
                                <p>Toma uno o m谩s patrones para "empalmar" en el patr贸n original. El nuevo patr贸n devuelto se compone de los valores del original y de las secuencias dadas de forma alternada.</p>


                                <p><code># Alternando entre dos secuencias</code></p>
                                <p><code>print(P[0, 1, 2, 3].splice([4, 5, 6, 7]))</code></p>
                                <p><code>P[0, 4, 1, 5, 2, 6, 3, 7]</code></p>
                                <p><code># Alternando entre tres secuencias</code></p>
                                <p><code>print(P[0, 2, 4].splice([1, 3, 5],[6, 7, 8]))</code></p>
                                <p><code>P[0, 1, 6, 2, 3, 7, 4, 5, 8]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                
    <h3>invert()</h3>

                                <p>Crea una versi贸n invertida del patr贸n restando sus valores del valor m谩s grande del patr贸n, de modo que el valor m谩s grande del patr贸n se convierte en el m谩s peque帽o (y viceversa) y se intercambia la diferencia entre otros valores y el m铆nimo/m谩ximo:</p>


                                <p><code>print(P[2, 5, 1, 11].invert())</code></p>
                                <p><code>P[10, 7, 11, 1]</code></p>
                                <p><code># Invertir una secuencia lineal lo invertir谩</code></p>
                                <p><code>print(P[0, 1, 2, 3].invert())</code></p>
                                <p><code>P[3, 2, 1, 0]</code></p>

                                   <hr style= "border-color: #4e7c5c; width:90%">
                               
    <h3>shufflets(n = 4)</h3>

                                <p>Devuelve un nuevo patr贸n que contiene el patr贸n original como un PGroup en orden aleatorio de longitud n.</p>


                                <p><code>print(P[0, 1, 2, 3].shufflets(3))</code></p>
                                <p><code>P[P(2, 3, 1, 0), P(3, 2, 0, 1), P(2, 1, 0, 3)]</code></p>

                                   <hr style= "border-color: #4e7c5c; width:90%">
                               
    <h3>pivot(i)</h3>
                                <p>Devuelve un nuevo patr贸n que es una versi贸n invertida del original pero girado de forma que el elemento en el 铆ndice i sigue estando en el mismo lugar.</p>

                                <p><code># En un patr贸n de longitud 5, un pivote a 2 mantendr谩 el elemento del medio en el mismo lugar</code></p>
                                <p><code>print(P[5, 1, 6, 2, 3].pivot(2))</code></p>
                                <p><code>P[3, 2, 6, 1, 5]</code></p>


                                   <hr style= "border-color: #4e7c5c; width:90%">
                              
    <h3>accum(n=Ninguna)</h3>
                                <p>Devuelve un patr贸n que es equivalente a la lista de sumas de ese patr贸n hasta ese 铆ndice (el primer valor es siempre 0). El argumento n especifica la longitud del nuevo patr贸n. Cuando n es Ninguno entonces el nuevo patr贸n toma la longitud del original.</p>

                                <p><code>#Acumulaci贸n de una serie de valores</code></p>
                                <p><code>print(P[1, 2, 3, 4].accum())</code></p>
                                <p><code>P[0, 1, 3, 6]</code></p>
                                <p><code># El nuevo valor puede ser m谩s largo que el original</code></p>
                                <p><code>imprimir(P[1, 2, 3, 4].accum(8))</code></p>
                                <p><code>P[0, 1, 3, 6, 10, 11, 13, 16]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                               
    <h3>stretch(size)</h3>
                                <p>Devuelve un patr贸n que se repite hasta que la longitud es igual al tama帽o.</p>


                                <p><code># Estira el patr贸n</code></p>
                                <p><code>print(P[1, 2, 3, 4].stretch(6))</code></p>
                                <p><code>P[1, 2, 3, 4, 1, 2]</code></p>
                                <p><code>El tama帽o puede ser menor que la longitud del original.</code></p>
                                <p><code>print(P[1, 2, 3, 4].stretch(3))</code></p>
                                <p><code>P[1, 2, 3]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                
    <h3>trim(size)</h3>
                                <p>Como estirar pero la longitud no puede exceder la longitud del patr贸n original.</p>

                                <p><code># Recorta el patr贸n a la longitud 3</code></p>
                                <p><code>print(P[1, 2, 3, 4, 5].trim(3))</code></p>
                                <p><code>P[1, 2, 3]</code></p>
                                <p><code># Se ignoran los valores de tama帽o mayores que la longitud</code></p>
                                <p><code>print(P[1, 2, 3, 4, 5].trim(10))</code></p>
                                <p><code>P[1, 2, 3, 4, 5]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                
    <h3>ltrim(tama帽o)</h3>
                                <p>Como recortar, pero elimina elementos del inicio del patr贸n, no del final.</p>


                                <p><code>print(P[1, 2, 3, 4, 5].ltrim(3))</code></p>
                                <p><code>P[3, 4, 5]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                               
    <h3>loop(n)</h3>
                                <p>Repite el patr贸n n veces. til cuando se encadenan m煤ltiples patrones. Los patrones anidados se tienen en cuenta cuando se realiza el bucle.</p>
                                <p><code># Repite el patr贸n dos veces</code></p>
                                <p><code>print(P[0, 1, 2, 3].loop(2))</code></p>
                                <p><code>P[0, 1, 2, 3, 0, 1, 2, 3]</code></p>
                                <p><code># Repite dos veces y encadena con otro patr贸n</code></p>
                                <p><code>print(P[0, 1, 2].loop(2) | P[7, 6])</code></p>
                                <p><code>P[0, 1, 2, 0, 1, 2, 7, 6]</code></p>
                                <p><code># Looping with nested patterns expands the nests</code></p>
                                <p><code>print(P[0,[1, 2]].loop(2))</code></p>
                                <p><code>P[0, 1, 0, 2, 0, 1, 0, 2]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                              
    <h3>duplicate(n)</h3>
                                <p>Como el bucle pero retiene los patrones anidados de tal manera que el primer valor en los nidos se utiliza en la primera iteraci贸n a trav茅s de la secuencia duplicada, etc.</p>


                                <p><code>#Mantenga los valores anidados al duplicar</code></p>
                                <p><code>print(P[0,[1, 2]].duplicate(2))</code></p>
                                <p><code>P[0, P[1, 2], 0, P[1, 2]]</code></p><p><code></code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>iter</h3>

                                <p>Como el bucle, pero no tiene en cuenta los patrones anidados al calcular la longitud.</p>

                                <p><code>print(P[0,[1, 2]].iter(2))</code></p>
                                <p><code>P[0, 1, 0, 2]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>swap(n)</h3>
                                <p>Cambia los lugares de los valores en el patr贸n. Cuando n es 2 entonces los valores uno al lado del otro son intercambiados, cuando n es 3 entonces los valores siguientes pero 1 son intercambiados, y as铆 sucesivamente.</p>

                                <p><code># Intercambiar valores uno al lado del otro</code></p>
                                <p><code>print(P[0, 1, 2, 3].swap(2))</code></p>
                                <p><code>P[1, 0, 3, 2]</code></p>
                                <p><code># Intercambiar valores separados por un paso</code></p>
                                <p><code>print(P[0, 1, 2, 3, 4, 5].swap(3))</code></p>
                                <p><code>P[2, 1, 0, 5, 4, 3]</code></p>

                                  <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>rotate(n)</h3>
                                <p>Devuelve un patr贸n con los valores del patr贸n original desplazados a la izquierda en orden por n n煤mero de lugares. Los n煤meros negativos desplazan los valores a la derecha.</p>




                                <p><code>#Gira a la izquierda a la 1</code></p>
                                <p><code>print(P[0, 1, 2, 3].rotate(1))</code></p>
                                <p><code>P[1, 2, 3, 0]</code></p>
                                <p><code># Gira a la derecha por 1</code></p>
                                <p><code>print(P[0, 1, 2, 3].rotate(-1))</code></p>
                                <p><code>P[3, 0, 1, 2]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                               
    <h3>sample(n)</h3>

                                <p>Devuelve un patr贸n de n-longitud con valores seleccionados aleatoriamente del patr贸n original. La n</p>


                                <p><code>print(P[0, 1, 2, 3].sample(3))</code></p> <p><code></code></p>
                                <p><code>P[3, 2, 0]</code></p>

                                   <hr style= "border-color: #4e7c5c; width:90%">
                             
    <h3>palindrome()</h3>

                                <p>A帽ade el reverso de un patr贸n sobre s铆 mismo de tal manera que crea un pal铆ndromo de n煤meros.</p>

                                <p><code>print(P[0, 1, 2, 3].palindrome())</code></p>
                                <p><code>P[0, 1, 2, 3, 3, 2, 1, 0]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">

                               
    <h3>alt(seq)</h3>

                                <p>Reemplaza el patr贸n con el de seq. Es 煤til si desea utilizar un patr贸n alternativo y asignarlo utilizando cada m茅todo.</p>


                                <p><code># Reemplaza el patr贸n</code></p>
                                <p><code>print(P[0, 1, 2, 3].alt([4, 5]))</code></p>
                                <p><code>P[4, 5]</code></p>
                                <p><code>#til cuando se usa con un Reproductor</code></p>
                                <p><code>p1 >> pads([0, 1, 2, 3]).every(6, "alt", P[4, 5, 6, 7])</code></p>


                                   <hr style= "border-color: #4e7c5c; width:90%">
                                
    <h3> norm()</h3>
                                <p>Devuelve un patr贸n con todos los valores normalizados de forma que cada valor del nuevo patr贸n est茅 entre 0 y 1.</p>
                                <p><code>print(P[0, 1, 2, 3].norm())</code></p>
                                <p><code>P[0.0, 0.3333333333333333, 0.6666666666666666, 1.0]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>undup()</h3>

                                <p>Elimina cualquier valor duplicado consecutivo para que no haya valores repetidos en el patr贸n.</p>
                                <p><code>print(P[0, 1, 1, 1, 1, 2, 2, 3].undup())</code></p>
                                <p><code>P[0, 1, 2, 3]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>limit(func, value)</h3>
                                <p>Devuelve un nuevo patr贸n generado a帽adiendo valores desde el original hasta que func(pattern) exceda el valor. El argumento func debe ser una funci贸n v谩lida, como len o suma.</p>
                                <p><code># Crea un patr贸n cuya suma no sea mayor de 7</code></p>
                                <p><code>print(P[0, 1, 2, 3].limit(sum, 7))</code></p>
                                <p><code>P[0, 1, 2, 3, 0, 1]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                               
    <h3>replace(sub, repl)</h3>
                                <p>Devuelve un nuevo patr贸n con valores iguales a sub reemplazado por repl.</p>

                                <p><code>#Sustituye los valores de 0 por 4</code></p>
                                <p><code>print(P[0, 1, 2, 3].replace(0, 4))</code></p>
                                <p><code>P[4, 1, 2, 3]</code></p>
                                <p><code># Tambi茅n reemplaza valores en grupos y patrones anidados</code></p>
                                <p><code>print(P[0, (1, 0), 2,[3, 0]].replace(0, 4))</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                               
    <h3>submap(mapping)</h3>
                                <p>Similar a reemplazar pero requiere un diccionario de sub para replicar valores y reemplazar m煤ltiples 铆tems.</p>


                                <p><code># Sustituir 0 por 4 y 1 por 5</code></p>
                                <p><code>print(P[0, 1, 2, 3].submap({0: 4, 1: 5}))</code></p>
                                <p><code>P[4, 5, 2, 3]</code></p>
                                <p><code>Tambi茅n funciona con valores anidados, etc.</code></p>
                                <p><code>print(P[0, (1, 0), 2,[3, 0]].submap({0: 4, 1: 5}))</code></p>
                                <p><code>P[4, P(5, 4), 2, P[3, 4]]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                               
    <h3>layer(method, *args, **kwargs)</h3>

                                <p>Cierra el patr贸n original con s铆 mismo pero con el m茅todo llamado en s铆 mismo, que debe ser un nombre de cadena de un m茅todo de patr贸n v谩lido (similar a Player.every). Sin embargo, el argumento del m茅todo tambi茅n puede ser una funci贸n (ejemplo a continuaci贸n).</p>

                                <p><code># Patr贸n con cremallera con su reverso</code></p>
                                <p><code>print(P[0, 1, 2, 3].layer("reverse"))</code></p>
                                <p><code>P[P(0, 3), P(1, 2), P(2, 1), P(3, 0)]</code></p>
                                <p><code> # Patr贸n con cremallera con swap(2) llamado en 茅l</code></p>
                                <p><code>print(P[0, 1, 2, 3].layer("swap", 2))</code></p>
                                <p><code>P[P(0, 1), P(1, 0), P(2, 3), P(3, 2)]</code></p>
                                <p><code># Zipped with a function multiplicando los valores por 2</code></p>
                                <p><code>print(P[0, 1, 2, 3].layer(lambda x: x + 2))</code></p>
                                <p><code>P[P(0, 2), P(1, 3), P(2, 4), P(3, 5)]</code></p>
                                <p><code># Esto es equivalente a abajo:</code></p>
                                <p><code>print(P[0, 1, 2, 3].layer("__add__", 2))</code></p>
                                <p><code>P[P(0, 2), P(1, 3), P(2, 4), P(3, 5)]</code></p>


                               
    <h3>every (n, method, *args, **kwargs) </h3>

                                <p>Repite el patr贸n original n veces y aplica el m茅todo Patr贸n (especificado como una cadena) en la 煤ltima repetici贸n con los args y kwargs suministrados. </p>

                                <p><code> # Invierta el patr贸n en la tercera repetici贸n </code></p>
                                <p><code> print(P[0, 1, 2, 3].every(3, "mirror")) </code></p>
                                <p><code> P[0, 1, 2, 3, 0, 1, 2, 3, 3, 2, 1, 0] </code></p>



    
                               
    <h3>map(callable)</h3>

                                <p>Devuelve un nuevo Patr贸n con el argumento llamable llamado en cada 铆tem del patr贸n.</p>

                                <p><code> # Poner todos los n煤meros pares a 0</code></p>
                                <p><code> print(P[0, 1, 2, 3].map(lambda x: 0 if x % 2 == 0 else x))</code></p>
                                <p><code> P[0, 1, 0, 3]</code><p>


                               
    <h3>extend (seq) </h3>

                                <p> Extiende el Patr贸n con la secuencia en su lugar, es decir, devuelve Ninguno a diferencia de un nuevo Patr贸n. Esto es m谩s eficiente que el m茅todo concat para combinar m煤ltiples secuencias en un Patr贸n. </p>

                                <p> <code>pat = P[0, 1, 2, 3] </code> </p>
                                <p> <code>pat.extend([4, (5, 6), 7]) </code> </p>
                                <p> <code>print(pat) </code> </p>
                                <p> <code>P[0, 1, 2, 3, 4, P(5, 6), 7]</code> </p>

                                
    <h3>contact (seq)</h3>

                                <p>Devuelve un nuevo Patr贸n con el contenido de seq a帽adido al final del Patr贸n original. El m茅todo especial __or__ (que usa la sintaxis |) tambi茅n llama a este m茅todo. </p>


                                <p> <code># Estas dos l铆neas son equivalentes</code> </p>
                                <p> <code>print(P[0, 1, 2, 3].concat([4, 5, 6])) </code> </p>
                                <p> <code> P[0, 1, 2, 3, 4, 5, 6]</code> </p>
                                <p> <code>print(P[0, 1, 2, 3] | [4, 5, 6]) </code> </p>
                                <p> <code> P[0, 1, 2, 3, 4, 5, 6]</code> </p>

                                <p>  Esto es 煤til para combinar varios Patrones dentro de un objeto de Reproductor, pero no es una forma eficaz de crear Patrones grandes usando un bucle. Intenta ejecutar los dos bloques de c贸digo y ver la diferencia. </p>

                                <p> <code># esto no es eficiente </code> </p>
                                <p> <code>pat = P[0, 1, 2] </code> </p>
                                <p> <code>for n in range(20000): </code> </p>
                                <p> <code>pat = pat | [0, 1, 2] </code> </p>
                                <p> <code>print(pat) </code> </p>

                                <p> <code> # este es eficiente</code> </p>
                                <p> <code>pat = P[0, 1, 2] </code> </p>
                                <p> <code>for n in range(20000): </code> </p>
                                <p> <code>pat.extend([0,1,2]) </code> </p>
                                <p> <code>print(pat) </code> </p>

                                
    <h3>zip (seq)</h3>

                                <p> El "Zipping" es el proceso de combinar dos secuencias en una en la que cada elemento es un grupo que contiene los elementos de cada secuencia en el mismo 铆ndice. Si las secuencias son de diferentes longitudes, entonces se comprimen hasta la longitud del m煤ltiplo com煤n m谩s bajo de ambas longitudes. </p>

                                <p> <code>print(P[0, 1, 2, 3].zip([4, 5])) </code> </p>
                                <p> <code> P[P(0, 4), P(1, 5), P(2, 4), P(3, 5)</code> </p>

                                
    <h3>offadd (value, dur=0.5)</h3>

                                <p>Agrega valor al Patr贸n, se cierra con el original, y retrasa el valor del cierre usando la clase PGroupPrime. </p>

                                <p> <code>print(P[0, 1, 2, 3].offadd(2, 0.5)) </code> </p>
                                <p> <code>P[P^(0, 2), P^(1, 3), P^(2, 4), P^(3, 5)]</code> </p>

                               
    <h3>offmul (value, dur=0.5)</h3>

                                <p>Similar a offadd pero multiplica los valores en lugar de sumar. </p>

                                <p> <code> print(P[0, 1, 2, 3].offmul(2, 0.5))</code> </p>
                                <p> <code> P[P^(0, 0), P^(1, 2), P^(2, 4), P^(3, 6)]</code> </p>



                                
    <h3>offlayer (method, dur=0.5, *args, **kwargs)</h3>

                                <p>Similar a offadd y offmul pero utiliza un m茅todo o funci贸n especificado por el usuario en lugar de la adici贸n/multiplicaci贸n. El argumento method debe ser un nombre v谩lido de un m茅todo Pattern como cadena o un objeto llamable como una funci贸n. Cualquier argumento extra o argumento de palabra clave se proporciona despu茅s de la duraci贸n para retrasar la capa, por lo tanto, la duraci贸n debe ser suministrada si se suministran argumentos como parte de *args. </p>

                                <p> <code># Capa con el m茅todo "rotar" con valores por defecto </code> </p>
                                <p> <code>print(P[0, 1, 2, 3].offlayer("rotate")) </code> </p>
                                <p> <code>P[P^(0, 1), P^(1, 2), P^(2, 3), P^(3, 0)] </code> </p>

                                <p> <code># Lo siguiente no es una capa con .rotate(2) sino con dur = 2 </code> </p>
                                <p> <code>print(P[0, 1, 2, 3].offlayer("rotate", 2)) </code> </p>
                                <p> <code>P[P^(0, 1), P^(1, 2), P^(2, 3), P^(3, 0)] </code> </p>


                                <p> <code># Se debe especificar la duraci贸n para suministrar 2 para rotar </code> </p>
                                <p> <code> print(P[0, 1, 2, 3].offlayer("rotate", 0.5, 2)) </code> </p>
                                <p> <code>P[P^(0, 2), P^(1, 3), P^(2, 0), P^(3, 1) </code> </p>


                                <p> <code># Tambi茅n puede utilizar funciones en lugar de nombres de m茅todos </code> </p>
                                <p> <code> print(P[0, 1, 2, 3].offlayer(lambda x: (x * 2) + 1))</code> </p>
                                <p> <code> P[P^(0, 1), P^(1, 3), P^(2, 5), P^(3, 7)]</code> </p>


                               
    <h3> amen ()</h3>

                                <p>Replica el ritmo y el orden del famoso "amen break" basado en una secuencia de kick-drum, hi-hat, snare-drum, hi-hat. Escuche el siguiente ejemplo: </p>

                                <p> <code> p1 >> play("x-o-").every(8, "amen")</code> </p>




</div>
</body>

    <div class="margenuno"> <a href="edr.html"> Atras </a> <a  href="ma.html">siguiente </a> </div>
<footer>
</footer>
