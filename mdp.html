<!DOCTYPE html>

<html lang="en" class="">

<head>

      <meta charset="UTF-8"/>
      <title> Metodos de patrones </title>
      <meta name="FoxDot | Livecoding"/>
      <link rel="stylesheet" type="text/css" href="css/..."/>
      <link rel="stylesheet" type="text/css" href="css/..."/>
    <link rel="stylesheet" type="text/css" href="css/normalize.css" />
		<link rel="stylesheet" type="text/css" href="css/demo.css" />
		<link rel="stylesheet" type="text/css" href="css/style-tsula.css" />

      <script> </script>

</head>
    
     <div class="margenuno">
 <heaheader  >
     <a href="index.html" ><img  src="img/LOGO.png" alt="Logo"  /></a>
     <h2 >python y supercollider</h2>
 

</heaheader>

    </div>

<body class="fondo">
<div class="margenuno">
    <h2> Metodos de patrones</h2>

                                <p>Esta es una lista no documentada de métodos que pueden ser usados con objetos Pattern.</p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                              
    <h3>shuffle(n=1)</h3>

                                <p>Devuelve el patrón con su contenido en un orden aleatorio y n es el número de permutaciones:</p>

                                <p><code># Una sola permutación de shuffle</code></p>
                                <p><code>print(P[0, 1, 2, 3].shuffle())</code></p>
                                <p><code>P[0, 3, 2, 1]</code></p>
                                <p><code># Dos permutaciones</code></p>
                                <p><code>print(P[0, 1, 2, 3].shuffle(2))</code></p>
                                <p><code>P[3, 1, 2, 0, 2, 1, 3, 0]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                               
    <h3> reverese()</h3>

                                <p>Devuelve el patrón con su contenido en orden inverso. Los patrones / grupos anidados son *no* invertidos. Use <code>Pattern.mirror </code>para obtener ese comportamiento:</p>

                                <p><code># Invierte el orden</code></p>
                                <p><code>P[0, 1, 2, 3].reverse()</code></p>
                                <p><code>P[3, 2, 1, 0]</code></p>
                                <p><code># El patrón anidado no se invierte cuando se usa "reverse"</code></p>
                                <p><code>P[[0, 4], 3, 2, 1].reverse()</code></p>
                                <p><code>P[1, 2, 3, P[0, 4]]</code></p>
                                <p><code># Usando mirror *does* reverse the nested patron</code></p>
                                <p><code>P[[0, 4], 3, 2, 1].mirror()</code></p>
                                <p><code>P[1, 2, 3, P[4, 0]]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                               
    <h3>mirror()</h3>

                                <p>Devuelve un patrón con su contenido en orden inverso, incluyendo patrones y grupos anidados:</p>

                                <p><code># Invierte el orden</code></p>
                                <p><code>P[3, 2, 1, 0]</code></p>
                                <p><code># Invertir patrones anidados y grupos</code></p>
                                <p><code>P[[0, 1], 2, 3, (4, 5)].mirror()</code></p>
                                <p><code>P[P(5, 4), 3, 2, P[1, 0]]</code></p>

                                   <hr style= "border-color: #4e7c5c; width:90%">
                               
    <h3>sort(*args, **kwargs)</h3>
                                <p>Devuelve un patrón con los valores ordenados. Los args y **kwargs son los que se suministran a la función ordenada integrada de Python pero esto devuelve un Patrón en lugar de una lista.</p>
                                <p><code># Ordenar en orden ascendente</code></p>
                                <p><code>print(P[1, 3, 2, 0].sort())</code></p>
                                <p><code>P[0, 1, 2, 3]</code></p>
                                <p><code># Ordenar por longitud del artículo</code></p>
                                <p><code>print(P[(1, 2), (3,), (4, 5, 6, 7), (8, 9, 10)].sort(key=lambda x: len(x)))</code></p>
                                <p><code>P[P(3), P(1, 2), P(8, 9, 10), P(4, 5, 6, 7)]</code></p>

                                   <hr style= "border-color: #4e7c5c; width:90%">
                               
    <h3>stutter(n=2)</h3>
                                <p>Devuelve un nuevo patrón con cada valor repetido n número de veces. Si n es un patrón en sí mismo, entonces cada valor se repite por el número en el mismo índice en el patrón dado.</p>


                                <p><code># Tartamudean cada valor 3 veces</code></p>
                                <p><code>print(P[0, 1, 2, 3].stutter(3))</code></p>
                                <p><code>P[0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3]</code></p>
                                <p><code># Tartamudea cada dos valores por dos</code></p>
                                <p><code>print(P[0, 1, 2, 3].stutter([1, 2]))</code></p>
                                <p><code>P[0, 1, 1, 2, 3, 3]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                               
    <h3>arp(seq)</h3>

                                <p>Devuelve un nuevo patrón con cada elemento repetido len(seq) veces e incrementado por los valores en seq. Útil para arpegiar.</p>

                                <p><code># Tartamudea de 2 en 2 y añade 4 a cada segundo de valor.</code></p>
                                <p><code>print(P[0, 1, 2, 3].arp([0, 4]))</code></p>
                                <p><code>P[0, 4, 1, 5, 2, 6, 3, 7]</code></p>


                                   <hr style= "border-color: #4e7c5c; width:90%">
                               
    <h3>splice(seq, *seqs)</h3>
                                <p>Toma uno o más patrones para "empalmar" en el patrón original. El nuevo patrón devuelto se compone de los valores del original y de las secuencias dadas de forma alternada.</p>


                                <p><code># Alternando entre dos secuencias</code></p>
                                <p><code>print(P[0, 1, 2, 3].splice([4, 5, 6, 7]))</code></p>
                                <p><code>P[0, 4, 1, 5, 2, 6, 3, 7]</code></p>
                                <p><code># Alternando entre tres secuencias</code></p>
                                <p><code>print(P[0, 2, 4].splice([1, 3, 5],[6, 7, 8]))</code></p>
                                <p><code>P[0, 1, 6, 2, 3, 7, 4, 5, 8]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                
    <h3>invert()</h3>

                                <p>Crea una versión invertida del patrón restando sus valores del valor más grande del patrón, de modo que el valor más grande del patrón se convierte en el más pequeño (y viceversa) y se intercambia la diferencia entre otros valores y el mínimo/máximo:</p>


                                <p><code>print(P[2, 5, 1, 11].invert())</code></p>
                                <p><code>P[10, 7, 11, 1]</code></p>
                                <p><code># Invertir una secuencia lineal lo invertirá</code></p>
                                <p><code>print(P[0, 1, 2, 3].invert())</code></p>
                                <p><code>P[3, 2, 1, 0]</code></p>

                                   <hr style= "border-color: #4e7c5c; width:90%">
                               
    <h3>shufflets(n = 4)</h3>

                                <p>Devuelve un nuevo patrón que contiene el patrón original como un PGroup en orden aleatorio de longitud n.</p>


                                <p><code>print(P[0, 1, 2, 3].shufflets(3))</code></p>
                                <p><code>P[P(2, 3, 1, 0), P(3, 2, 0, 1), P(2, 1, 0, 3)]</code></p>

                                   <hr style= "border-color: #4e7c5c; width:90%">
                               
    <h3>pivot(i)</h3>
                                <p>Devuelve un nuevo patrón que es una versión invertida del original pero girado de forma que el elemento en el índice i sigue estando en el mismo lugar.</p>

                                <p><code># En un patrón de longitud 5, un pivote a 2 mantendrá el elemento del medio en el mismo lugar</code></p>
                                <p><code>print(P[5, 1, 6, 2, 3].pivot(2))</code></p>
                                <p><code>P[3, 2, 6, 1, 5]</code></p>


                                   <hr style= "border-color: #4e7c5c; width:90%">
                              
    <h3>accum(n=Ninguna)</h3>
                                <p>Devuelve un patrón que es equivalente a la lista de sumas de ese patrón hasta ese índice (el primer valor es siempre 0). El argumento n especifica la longitud del nuevo patrón. Cuando n es Ninguno entonces el nuevo patrón toma la longitud del original.</p>

                                <p><code>#Acumulación de una serie de valores</code></p>
                                <p><code>print(P[1, 2, 3, 4].accum())</code></p>
                                <p><code>P[0, 1, 3, 6]</code></p>
                                <p><code># El nuevo valor puede ser más largo que el original</code></p>
                                <p><code>imprimir(P[1, 2, 3, 4].accum(8))</code></p>
                                <p><code>P[0, 1, 3, 6, 10, 11, 13, 16]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                               
    <h3>stretch(size)</h3>
                                <p>Devuelve un patrón que se repite hasta que la longitud es igual al tamaño.</p>


                                <p><code># Estira el patrón</code></p>
                                <p><code>print(P[1, 2, 3, 4].stretch(6))</code></p>
                                <p><code>P[1, 2, 3, 4, 1, 2]</code></p>
                                <p><code>El tamaño puede ser menor que la longitud del original.</code></p>
                                <p><code>print(P[1, 2, 3, 4].stretch(3))</code></p>
                                <p><code>P[1, 2, 3]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                
    <h3>trim(size)</h3>
                                <p>Como estirar pero la longitud no puede exceder la longitud del patrón original.</p>

                                <p><code># Recorta el patrón a la longitud 3</code></p>
                                <p><code>print(P[1, 2, 3, 4, 5].trim(3))</code></p>
                                <p><code>P[1, 2, 3]</code></p>
                                <p><code># Se ignoran los valores de tamaño mayores que la longitud</code></p>
                                <p><code>print(P[1, 2, 3, 4, 5].trim(10))</code></p>
                                <p><code>P[1, 2, 3, 4, 5]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                
    <h3>ltrim(tamaño)</h3>
                                <p>Como recortar, pero elimina elementos del inicio del patrón, no del final.</p>


                                <p><code>print(P[1, 2, 3, 4, 5].ltrim(3))</code></p>
                                <p><code>P[3, 4, 5]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                               
    <h3>loop(n)</h3>
                                <p>Repite el patrón n veces. Útil cuando se encadenan múltiples patrones. Los patrones anidados se tienen en cuenta cuando se realiza el bucle.</p>
                                <p><code># Repite el patrón dos veces</code></p>
                                <p><code>print(P[0, 1, 2, 3].loop(2))</code></p>
                                <p><code>P[0, 1, 2, 3, 0, 1, 2, 3]</code></p>
                                <p><code># Repite dos veces y encadena con otro patrón</code></p>
                                <p><code>print(P[0, 1, 2].loop(2) | P[7, 6])</code></p>
                                <p><code>P[0, 1, 2, 0, 1, 2, 7, 6]</code></p>
                                <p><code># Looping with nested patterns expands the nests</code></p>
                                <p><code>print(P[0,[1, 2]].loop(2))</code></p>
                                <p><code>P[0, 1, 0, 2, 0, 1, 0, 2]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                              
    <h3>duplicate(n)</h3>
                                <p>Como el bucle pero retiene los patrones anidados de tal manera que el primer valor en los nidos se utiliza en la primera iteración a través de la secuencia duplicada, etc.</p>


                                <p><code>#Mantenga los valores anidados al duplicar</code></p>
                                <p><code>print(P[0,[1, 2]].duplicate(2))</code></p>
                                <p><code>P[0, P[1, 2], 0, P[1, 2]]</code></p><p><code></code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>iter</h3>

                                <p>Como el bucle, pero no tiene en cuenta los patrones anidados al calcular la longitud.</p>

                                <p><code>print(P[0,[1, 2]].iter(2))</code></p>
                                <p><code>P[0, 1, 0, 2]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>swap(n)</h3>
                                <p>Cambia los lugares de los valores en el patrón. Cuando n es 2 entonces los valores uno al lado del otro son intercambiados, cuando n es 3 entonces los valores siguientes pero 1 son intercambiados, y así sucesivamente.</p>

                                <p><code># Intercambiar valores uno al lado del otro</code></p>
                                <p><code>print(P[0, 1, 2, 3].swap(2))</code></p>
                                <p><code>P[1, 0, 3, 2]</code></p>
                                <p><code># Intercambiar valores separados por un paso</code></p>
                                <p><code>print(P[0, 1, 2, 3, 4, 5].swap(3))</code></p>
                                <p><code>P[2, 1, 0, 5, 4, 3]</code></p>

                                  <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>rotate(n)</h3>
                                <p>Devuelve un patrón con los valores del patrón original desplazados a la izquierda en orden por n número de lugares. Los números negativos desplazan los valores a la derecha.</p>




                                <p><code>#Gira a la izquierda a la 1</code></p>
                                <p><code>print(P[0, 1, 2, 3].rotate(1))</code></p>
                                <p><code>P[1, 2, 3, 0]</code></p>
                                <p><code># Gira a la derecha por 1</code></p>
                                <p><code>print(P[0, 1, 2, 3].rotate(-1))</code></p>
                                <p><code>P[3, 0, 1, 2]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                               
    <h3>sample(n)</h3>

                                <p>Devuelve un patrón de n-longitud con valores seleccionados aleatoriamente del patrón original. La n</p>


                                <p><code>print(P[0, 1, 2, 3].sample(3))</code></p> <p><code></code></p>
                                <p><code>P[3, 2, 0]</code></p>

                                   <hr style= "border-color: #4e7c5c; width:90%">
                             
    <h3>palindrome()</h3>

                                <p>Añade el reverso de un patrón sobre sí mismo de tal manera que crea un palíndromo de números.</p>

                                <p><code>print(P[0, 1, 2, 3].palindrome())</code></p>
                                <p><code>P[0, 1, 2, 3, 3, 2, 1, 0]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">

                               
    <h3>alt(seq)</h3>

                                <p>Reemplaza el patrón con el de seq. Es útil si desea utilizar un patrón alternativo y asignarlo utilizando cada método.</p>


                                <p><code># Reemplaza el patrón</code></p>
                                <p><code>print(P[0, 1, 2, 3].alt([4, 5]))</code></p>
                                <p><code>P[4, 5]</code></p>
                                <p><code>#Útil cuando se usa con un Reproductor</code></p>
                                <p><code>p1 >> pads([0, 1, 2, 3]).every(6, "alt", P[4, 5, 6, 7])</code></p>


                                   <hr style= "border-color: #4e7c5c; width:90%">
                                
    <h3> norm()</h3>
                                <p>Devuelve un patrón con todos los valores normalizados de forma que cada valor del nuevo patrón esté entre 0 y 1.</p>
                                <p><code>print(P[0, 1, 2, 3].norm())</code></p>
                                <p><code>P[0.0, 0.3333333333333333, 0.6666666666666666, 1.0]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>undup()</h3>

                                <p>Elimina cualquier valor duplicado consecutivo para que no haya valores repetidos en el patrón.</p>
                                <p><code>print(P[0, 1, 1, 1, 1, 2, 2, 3].undup())</code></p>
                                <p><code>P[0, 1, 2, 3]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>limit(func, value)</h3>
                                <p>Devuelve un nuevo patrón generado añadiendo valores desde el original hasta que func(pattern) exceda el valor. El argumento func debe ser una función válida, como len o suma.</p>
                                <p><code># Crea un patrón cuya suma no sea mayor de 7</code></p>
                                <p><code>print(P[0, 1, 2, 3].limit(sum, 7))</code></p>
                                <p><code>P[0, 1, 2, 3, 0, 1]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                               
    <h3>replace(sub, repl)</h3>
                                <p>Devuelve un nuevo patrón con valores iguales a sub reemplazado por repl.</p>

                                <p><code>#Sustituye los valores de 0 por 4</code></p>
                                <p><code>print(P[0, 1, 2, 3].replace(0, 4))</code></p>
                                <p><code>P[4, 1, 2, 3]</code></p>
                                <p><code># También reemplaza valores en grupos y patrones anidados</code></p>
                                <p><code>print(P[0, (1, 0), 2,[3, 0]].replace(0, 4))</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                               
    <h3>submap(mapping)</h3>
                                <p>Similar a reemplazar pero requiere un diccionario de sub para replicar valores y reemplazar múltiples ítems.</p>


                                <p><code># Sustituir 0 por 4 y 1 por 5</code></p>
                                <p><code>print(P[0, 1, 2, 3].submap({0: 4, 1: 5}))</code></p>
                                <p><code>P[4, 5, 2, 3]</code></p>
                                <p><code>También funciona con valores anidados, etc.</code></p>
                                <p><code>print(P[0, (1, 0), 2,[3, 0]].submap({0: 4, 1: 5}))</code></p>
                                <p><code>P[4, P(5, 4), 2, P[3, 4]]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                               
    <h3>layer(method, *args, **kwargs)</h3>

                                <p>Cierra el patrón original con sí mismo pero con el método llamado en sí mismo, que debe ser un nombre de cadena de un método de patrón válido (similar a Player.every). Sin embargo, el argumento del método también puede ser una función (ejemplo a continuación).</p>

                                <p><code># Patrón con cremallera con su reverso</code></p>
                                <p><code>print(P[0, 1, 2, 3].layer("reverse"))</code></p>
                                <p><code>P[P(0, 3), P(1, 2), P(2, 1), P(3, 0)]</code></p>
                                <p><code> # Patrón con cremallera con swap(2) llamado en él</code></p>
                                <p><code>print(P[0, 1, 2, 3].layer("swap", 2))</code></p>
                                <p><code>P[P(0, 1), P(1, 0), P(2, 3), P(3, 2)]</code></p>
                                <p><code># Zipped with a function multiplicando los valores por 2</code></p>
                                <p><code>print(P[0, 1, 2, 3].layer(lambda x: x + 2))</code></p>
                                <p><code>P[P(0, 2), P(1, 3), P(2, 4), P(3, 5)]</code></p>
                                <p><code># Esto es equivalente a abajo:</code></p>
                                <p><code>print(P[0, 1, 2, 3].layer("__add__", 2))</code></p>
                                <p><code>P[P(0, 2), P(1, 3), P(2, 4), P(3, 5)]</code></p>


                               
    <h3>every (n, method, *args, **kwargs) </h3>

                                <p>Repite el patrón original n veces y aplica el método Patrón (especificado como una cadena) en la última repetición con los args y kwargs suministrados. </p>

                                <p><code> # Invierta el patrón en la tercera repetición </code></p>
                                <p><code> print(P[0, 1, 2, 3].every(3, "mirror")) </code></p>
                                <p><code> P[0, 1, 2, 3, 0, 1, 2, 3, 3, 2, 1, 0] </code></p>



    
                               
    <h3>map(callable)</h3>

                                <p>Devuelve un nuevo Patrón con el argumento llamable llamado en cada ítem del patrón.</p>

                                <p><code> # Poner todos los números pares a 0</code></p>
                                <p><code> print(P[0, 1, 2, 3].map(lambda x: 0 if x % 2 == 0 else x))</code></p>
                                <p><code> P[0, 1, 0, 3]</code><p>


                               
    <h3>extend (seq) </h3>

                                <p> Extiende el Patrón con la secuencia en su lugar, es decir, devuelve Ninguno a diferencia de un nuevo Patrón. Esto es más eficiente que el método concat para combinar múltiples secuencias en un Patrón. </p>

                                <p> <code>pat = P[0, 1, 2, 3] </code> </p>
                                <p> <code>pat.extend([4, (5, 6), 7]) </code> </p>
                                <p> <code>print(pat) </code> </p>
                                <p> <code>P[0, 1, 2, 3, 4, P(5, 6), 7]</code> </p>

                                
    <h3>contact (seq)</h3>

                                <p>Devuelve un nuevo Patrón con el contenido de seq añadido al final del Patrón original. El método especial __or__ (que usa la sintaxis |) también llama a este método. </p>


                                <p> <code># Estas dos líneas son equivalentes</code> </p>
                                <p> <code>print(P[0, 1, 2, 3].concat([4, 5, 6])) </code> </p>
                                <p> <code> P[0, 1, 2, 3, 4, 5, 6]</code> </p>
                                <p> <code>print(P[0, 1, 2, 3] | [4, 5, 6]) </code> </p>
                                <p> <code> P[0, 1, 2, 3, 4, 5, 6]</code> </p>

                                <p>  Esto es útil para combinar varios Patrones dentro de un objeto de Reproductor, pero no es una forma eficaz de crear Patrones grandes usando un bucle. Intenta ejecutar los dos bloques de código y ver la diferencia. </p>

                                <p> <code># esto no es eficiente </code> </p>
                                <p> <code>pat = P[0, 1, 2] </code> </p>
                                <p> <code>for n in range(20000): </code> </p>
                                <p> <code>pat = pat | [0, 1, 2] </code> </p>
                                <p> <code>print(pat) </code> </p>

                                <p> <code> # este es eficiente</code> </p>
                                <p> <code>pat = P[0, 1, 2] </code> </p>
                                <p> <code>for n in range(20000): </code> </p>
                                <p> <code>pat.extend([0,1,2]) </code> </p>
                                <p> <code>print(pat) </code> </p>

                                
    <h3>zip (seq)</h3>

                                <p> El "Zipping" es el proceso de combinar dos secuencias en una en la que cada elemento es un grupo que contiene los elementos de cada secuencia en el mismo índice. Si las secuencias son de diferentes longitudes, entonces se comprimen hasta la longitud del múltiplo común más bajo de ambas longitudes. </p>

                                <p> <code>print(P[0, 1, 2, 3].zip([4, 5])) </code> </p>
                                <p> <code> P[P(0, 4), P(1, 5), P(2, 4), P(3, 5)</code> </p>

                                
    <h3>offadd (value, dur=0.5)</h3>

                                <p>Agrega valor al Patrón, se cierra con el original, y retrasa el valor del cierre usando la clase PGroupPrime. </p>

                                <p> <code>print(P[0, 1, 2, 3].offadd(2, 0.5)) </code> </p>
                                <p> <code>P[P^(0, 2), P^(1, 3), P^(2, 4), P^(3, 5)]</code> </p>

                               
    <h3>offmul (value, dur=0.5)</h3>

                                <p>Similar a offadd pero multiplica los valores en lugar de sumar. </p>

                                <p> <code> print(P[0, 1, 2, 3].offmul(2, 0.5))</code> </p>
                                <p> <code> P[P^(0, 0), P^(1, 2), P^(2, 4), P^(3, 6)]</code> </p>



                                
    <h3>offlayer (method, dur=0.5, *args, **kwargs)</h3>

                                <p>Similar a offadd y offmul pero utiliza un método o función especificado por el usuario en lugar de la adición/multiplicación. El argumento method debe ser un nombre válido de un método Pattern como cadena o un objeto llamable como una función. Cualquier argumento extra o argumento de palabra clave se proporciona después de la duración para retrasar la capa, por lo tanto, la duración debe ser suministrada si se suministran argumentos como parte de *args. </p>

                                <p> <code># Capa con el método "rotar" con valores por defecto </code> </p>
                                <p> <code>print(P[0, 1, 2, 3].offlayer("rotate")) </code> </p>
                                <p> <code>P[P^(0, 1), P^(1, 2), P^(2, 3), P^(3, 0)] </code> </p>

                                <p> <code># Lo siguiente no es una capa con .rotate(2) sino con dur = 2 </code> </p>
                                <p> <code>print(P[0, 1, 2, 3].offlayer("rotate", 2)) </code> </p>
                                <p> <code>P[P^(0, 1), P^(1, 2), P^(2, 3), P^(3, 0)] </code> </p>


                                <p> <code># Se debe especificar la duración para suministrar 2 para rotar </code> </p>
                                <p> <code> print(P[0, 1, 2, 3].offlayer("rotate", 0.5, 2)) </code> </p>
                                <p> <code>P[P^(0, 2), P^(1, 3), P^(2, 0), P^(3, 1) </code> </p>


                                <p> <code># También puede utilizar funciones en lugar de nombres de métodos </code> </p>
                                <p> <code> print(P[0, 1, 2, 3].offlayer(lambda x: (x * 2) + 1))</code> </p>
                                <p> <code> P[P^(0, 1), P^(1, 3), P^(2, 5), P^(3, 7)]</code> </p>


                               
    <h3> amen ()</h3>

                                <p>Replica el ritmo y el orden del famoso "amen break" basado en una secuencia de kick-drum, hi-hat, snare-drum, hi-hat. Escuche el siguiente ejemplo: </p>

                                <p> <code> p1 >> play("x-o-").every(8, "amen")</code> </p>




</div>
</body>

    <div class="margenuno"> <a href="edr.html"> Atras </a></div>
    <div class="siguiente">  <a  href="ma.html">siguiente </a> </div>
<footer>
</footer>
