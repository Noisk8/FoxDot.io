<!DOCTYPE html>

<html lang="en" class="">

<head>

      <meta charset="UTF-8"/>
      <title> Patrones Basicos </title>
      <meta name="FoxDot | Livecoding"/>
      <link rel="stylesheet" type="text/css" href="css/normalize.css" />
		<link rel="stylesheet" type="text/css" href="css/demo.css" />
		<link rel="stylesheet" type="text/css" href="css/style-tsula.css" />

      <script> </script>

</head>


 <div class="margenuno">
  <heaheader  >
    <a href="index.html" ><h1> ü¶ä</h1></a>
  
      <h2 >Foxdot / Renardo </h2>


</heaheader>

    </div>



<body class="fondo">
    
    <div class="margenuno">
    <h2>Patrones basicos</h2>
								
							<h3> C√≥mo usar patrones</h3>
                            <p> Los objetos del reproductor utilizan listas Python, a menudo conocidas como arrays en otros lenguajes de programaci√≥n, para crear secuencias de valores, como afinaci√≥n y duraci√≥n. Sin embargo, las listas no son las estructuras de datos m√°s intuitivas para las transformaciones. Por ejemplo, trate de multiplicar una lista - ¬øqu√© sucede?</p>
                                
                            <p>    <code>print([1, 2, 3] * 2)</code></p>
                                
                                <p>El resultado es la misma lista repetida dos veces! Si quieres manipular los valores internos (por ejemplo, duplicarlos) en Python, puedes hacerlo de la siguiente manera:</p>
                                
                                <p> <code> values = [1, 2, 3]</code></p>
 
                            <p><code># Use a loop</code></p>
                             <p> <code>  my_list = []</code></p>
                              <p> <code> for i in values:</code></p>
                             <p> <code>      my_list.append(i * 2)</code></p>
                             <p>  <code> print(my_list)</code></p>

                                <p><code> # List comprehension</code></p>
                                <p>  <code> print([i*2 for i in values])
                                
                                </code></p>

                                <p> Para ambos m√©todos, requiere tener que recorrer en bucle todos los valores y multiplicar cada uno individualmente. Las cosas se complican a√∫n m√°s si tambi√©n quieres multiplicar cada segundo valor por un n√∫mero diferente. Esto requiere bastante trabajo, especialmente si no sabes qu√© n√∫meros vas a usar. Aqu√≠ es donde entra la clase de Patrones. </p>

<p> Los patrones act√∫an como las listas regulares de Python pero cualquier transformaci√≥n matem√°tica que se realice en ellas se hace a cada √≠tem de la lista. La forma m√°s sencilla de crear un patr√≥n es a√±adir una "P" may√∫scula al comienzo de una lista:</p>
                                
                            <p>    <code>
                                    my_list    = [0, 1, 2, 3]</code></p>
                              <p>  <code> my_pattern = P[0, 1, 2, 3]
                                </code></p>
                                
                                <p>Ahora, cuando realice una operaci√≥n, como una multiplicaci√≥n, obtendr√° el patr√≥n transformado:</p>
                                
                                <p><code>print(my_pattern * 2)</code></p>
                               <p><code> P[0, 2, 4, 6]
                                </code></p>
                                
                                <p> Tambi√©n puede crear un patr√≥n como lo har√≠a con cualquier otro objeto Python usando el nombre de la clase seguido de corchetes con argumentos:</p>
                                
                               <p> <code>my_pattern = Pattern([0, 1, 2, 3])</code></p>
                                
                                <p> Los patrones tambi√©n son "modulo indexable" lo que significa que no importa qu√© valor usemos como √≠ndice cuando accedemos a los datos de un Patr√≥n, siempre y cuando sea un entero obtenemos un valor devuelto. Si el √≠ndice es mayor que la longitud del Patr√≥n, entonces volvemos al principio del Patr√≥n y empezamos a buscar:</p>
                                
                            <p><code> pat = P[0, 1, 2]</code></p>
                            <p><code>print(pat[2])</code></p>
                           <p><code> 2</code></p>
                              <p> <code> print(pat[3])</code></p>
                             <p><code>   0</code></p>
                                
                                <h3> Transformaciones </h3>
                                <p> Puede realizar una operaci√≥n sobre un patr√≥n utilizando una lista u otro patr√≥n para crear transformaciones m√°s complejas. Por ejemplo, sumando los patrones <code>P[0, 1, 2, 3] </code> y <code>P[4, 7] </code>se realizar√° la operaci√≥n, lo que significa que el patr√≥n resultante ser√° el resultado <code>P[0 + 4, 1 + 7, 2 + 4, 3 + 7]</code> que es <code> P[4, 8, 6, 10]</code> El uso de patrones de longitudes sin divisor com√∫n crear√° un nuevo patr√≥n que contiene todos los valores de las combinaciones:</p>
                                
                            <p> <code> >>> P[0, 1, 2, 3] + P[4, 5, -2]</code></p>
                              <p><code>  P[4, 6, 0, 7, 5, -1, 6, 8, -2, 5, 7, 1]</code></p>
                                
                                <p> Los patrones tambi√©n tienen m√©todos espec√≠ficos para la transformaci√≥n, como <code> rotar, invertir y clasificar,</code>  que pueden utilizarse para manipular el orden:</p>
                                
                               <p><code>P[4, 1, 3, 2].rotate()</code></p> 
                               <p><code>P[1, 3, 2, 4]</code></p>
                                <p><code>P[4, 1, 3, 2].reverse()</code></p>
                                <p><code>P[2, 3, 1, 4]</code></p>
                                <p><code> P[4, 1, 3, 2].sort()</code></p>
                              <p> <code> P[1, 2, 3, 4] </code></p>
                                
                                
                                <p> Puede evaluar <code>help(Pattern)</code> para ver m√°s informaci√≥n sobre los m√©todos.</p>
                                
                                <h3> Funciones del patron</h3>
                                
                                <p> Hay una serie de funciones que devuelven diferentes Patrones. Estos generan Patrones m√°s largos usando s√≥lo unos pocos argumentos. Para ver una lista de funciones de Patr√≥n, puede evaluar la ayuda (Patrones.Secuencias). En Python, puedes generar un rango de enteros con el rango de sintaxis (inicio, parada, paso). Por defecto, el inicio es 0 y el paso es 1. Puede utilizar PRange (inicio, parada, paso) para crear un objeto Pattern con los valores equivalentes:</p>
                                
                              <p>  <code> print(list(range(0, 10 2)))</code></p>
                               <p><code> [0, 2, 4, 6, 8]</code></p>
                                <p><code>print(PRange(0, 10, 2))</code></p>
                              <p><code>  P[0, 2, 4, 6, 8]</code></p>
                                 
                                
                                <p> Y debido a que estas instancias de retorno de Patr√≥n podemos tratarlas como objetos de Patr√≥n y usar m√©todos de Patr√≥n y realizar operaciones aritm√©ticas sobre ellas as√≠:</p>
                                
                               <p><code> 
                                   print(PRange(0, 10, 2).reverse() + [1, 2])</code></p>
                                <p> <code>P[9, 8, 5, 4, 1, 10, 7, 6, 3, 2]</code></p>
                                
                                
                                <h3> Concatenando Patrones </h3>
                                
                                <p> En Python, normalmente se concatenan dos listas (se agrega una a otra) usando el operador + pero ya hemos visto que haciendo esto con Patterns se a√±aden los valores de un patr√≥n a los contenidos de otro. Para concatenar dos objetos Pattern juntos, puede usar el s√≠mbolo pipe, |, con el que los usuarios de Linux pueden estar familiarizados - se usa para conectar programas de l√≠nea de comandos enviando salida de un proceso como entrada a otro.</p>
                                
                                <p><code>  print(PRange(4) | [1,7,6])</code></p> 
                                    <p> <code>   P[0, 1, 2, 3, 1, 7, 6]
                                </code></p>
                                
                                <h3> Cordones de patrones y PGroups </h3>
                                
                                <p>¬øQu√© sucede cuando un Patr√≥n contiene una lista anidada como √©sta?</p>
                                
                                <p><code> pat = P[0, 2, [3, 5]]</code></p>
                                        <p><code>print(pat)</code></p>
                                      <p><code>  P[0, 2, P[3, 5]]</code></p>
                                
                                
                                <p> En primer lugar, la lista anidada se convierte en un patr√≥n (y cualquier lista anidada que pudiera contener tambi√©n se convierte). Si intentamos acceder al patr√≥n anidado aqu√≠ es lo que pasa:</p>
                                
                              <p>  <code>
 
                                  print(pat[0])</code></p>
                               <p> <code>0</code></p>
                                <p><code>print(pat[1])</code></p>
                               <p><code> 2</code></p>
                               <p><code> 3  print(pat[2])</code></p>
                               
                               
                                
                                <p> ¬øEso es extra√±o...? Se te perdonar√≠a por pensar que la √∫ltima l√≠nea devolver√≠a P[3, 5] porque ese es el objeto en la tercera ranura de la palmadita, pero no es as√≠ como se comportan los Patrones. Los patrones est√°n entrelazados, lo que significa que los valores de los patrones anidados se devuelven cuando se accede a su patr√≥n padre. Para acceder al segundo valor del patr√≥n anidado en el ejemplo anterior necesitamos hacer un bucle a trav√©s del Patr√≥n por segunda vez, es decir, usar un valor de √≠ndice mayor que la longitud del Patr√≥n:</p>
                                
                                <p><code>   for i in range(6):  </code></p>
                                        <p><code>   print(pat[i],)  </code></p>
                                      <p><code>   0, 2, 3, 0, 2, 5
                                
                                          </code></p>
                                
                                <p> Debido a esto, cuando imprima la longitud de un Patr√≥n, ver√° el tama√±o del Patr√≥n como si estuviera expandido como est√° arriba. Si usas par√©ntesis redondos y anidas una tupla de valores, ver√°s que sucede algo muy diferente:</p>
                                
                               <p> <code>pat = P[0, 2, (3, 5)]</code></p>
                                    <p><code>  print(pat)</code></p>
                                     <p><code>    P[0, 2, P(3, 5)]</code></p>
                                
                                
                                <p> El √∫ltimo √≠tem en el patr√≥n se conoce como un PGroup y se usa para mantener los valores dentro de un patr√≥n juntos, es decir, no enlazados:</p>
                                
                                <p><code>  print(pat[0])</code></p>
                                      <p><code>  0</code></p>
                                      <p><code>   print(pat[1])</code></p>
                                    <p><code>    2</code></p>
                                   <p><code>    print(pat[2])</code></p>
                                   <p>  <code>  P(3, 5)</code></p>
                                
                                <p> Agrupar valores significa que se tocan al mismo tiempo y esto es muy √∫til cuando se desea tocar notas juntos, por ejemplo, acordes:</p>
                                
                              <p><code> p1 >> pluck([(0, 2, 4), (0, 3, 5)], dur=4) </code></p>  
                                
                                <p> Puede agregar tuplas/ PGrupos a un Patr√≥n para crear un nuevo patr√≥n de elementos de PGrupo:</p>
                                
                                <p> <code> pat = P[0, 3, 5, 4]</code></p>
                                   <p> <code>     print(pat + (0, 2))</code></p>
                                    <p> <code>    P[P(0, 2), P(3, 5), P(5, 7), P(4, 6)]</code></p>
                                    <p> <code>    print(pat + [(0, 2), (2, 4)])</code></p>
                                        <p> <code>    P[P(0, 2), P(5, 7), P(5, 7), P(6, 8)]</code></p>
        
        </div>
                                
                                

</body>
<div class="margenuno"> <a href="or.html"> Atras </a> <a  href="vdt.html">siguiente </a> </div>
<footer>
</footer>