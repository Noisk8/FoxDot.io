<!DOCTYPE html>
<html lang="en" class="no-js">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"> 
		<meta name="viewport" content="width=device-width, initial-scale=1.0"> 
		<title>FoxDot en español</title>
		<meta name="description" content="Fullscreen Pageflip Layout with BookBlock" />
		<meta name="keywords" content="fullscreen pageflip, booklet, layout, bookblock, jquery plugin, flipboard layout, sidebar menu" />
		<meta name="FD" content="FoxDot" />
		<link rel="shortcut icon" href="../favicon.ico"> 
		<link rel="stylesheet" type="text/css" href="css/jquery.jscrollpane.custom.css" />
		<link rel="stylesheet" type="text/css" href="css/bookblock.css" />
		<link rel="stylesheet" type="text/css" href="css/custom.css" />
		<script src="js/modernizr.custom.79639.js"></script>
	</head>
	<body>
		<div id="container" class="container">	

			<div class="menu-panel">
				<h3>Tabla de Contenidos</h3>
				<ul id="menu-toc" class="menu-toc">
					<li class="menu-toc-current"><a href="#item1">FoxDot</a></li>
					<li><a href="#item2">Instalación</a></li>
					<li><a href="#item3">Primeros sonidos</a></li>
                    <li><a href="#item4"> Intro </a></li>
					<li><a href="#item5">Patrones Basicos</a></li>
					<li><a href="#item6">Variables dependientes del tiempo</a></li>
					<li><a href="#item7">Atributos del Reroductor</a></li>
					<li><a href="#item8"> Efectos del Reproductor </a></li>
					<li><a href="#item9"> Metodos del Reproductor </a></li>
					<li><a href="#item10"> Manipulación algoritmica</a></li>
					<li><a href="#item11"> Escalas y afinación </a></li>
                    <li><a href="#item12"> Configuración MIDI </a></li>
                     <li><a href="#item13">Usando tu propio SynthDef</a></li>
                     <li><a href="#item14">Metodos de patrones </a></li>
                     <li><a href="#item15"> Renderizador de voz </a></li>
                    <li><a href="#item16"> Problemas frecuentes </a></li>
                     

				</ul>
				<div>
					<a href="https://foxdot.org/">Pagína Oficial de FoxDot </a>
                    <a href="http://docs.foxdot.org/">Referencía de la guía</a>
				
				</div>
			</div>

			<div class="bb-custom-wrapper">
				<div id="bb-bookblock" class="bb-bookblock">
					<div class="bb-item" id="item1">
						<div class="content">
							<div class="scroller">
								<h2>Livecoding con Python y Supercollider</h2>
  	<img src="img/111.png" alt="FoxDot" >
								
								
						<p>FoxDot, se creó en 2015 para intentar abrir las vías de Live Coding para los usuarios que pueden ser nuevos en la programación y desean usarla para crear música rápida y fácilmente. FoxDot es una biblioteca de Python fácil de usar que crea un entorno de programación interactiva y habla con el potente motor de síntesis de sonido, llamado SuperCollider para hacer música. FoxDot programa eventos musicales de una manera sencilla y fácil de usar que hace que la codificación en vivo sea fácil y divertida tanto para los recién llegados como para los veteranos de programación.</p>
						
						
                       <hr style= "border-color: #4e7c5c; width:90%">

								<h3> Funcionamiento </h3>

								<p>FoxDot utiliza a supercollider como motor sonoro de sus syntetizadores, los interpreta a partir de sintaxis de python y con la liberria tcl crea el ide que utilizamos para depositar el código</p>
								
								<img src="img/FoxDotRun.png" alt="FoxDot" width="800" height="500" >

								<p> </p>

								<p> </p>

	
							</div>
						</div>
					</div>
				    <div class="bb-item" id="item2">
						<div class="content">
							<div class="scroller">
								<h2>Instalación</h2>
								
								<p> Siga las instrucciones de instalación para sus descargas de Python y SuperCollider. Cuando instale Python, haga clic en sí cuando se le pregunte si desea añadir Python a la ruta de su sistema y sí si desea instalar pip - esto se utiliza para descargar/instalar automáticamente bibliotecas de Python como FoxDot.</p>

<p> Instale la última versión de FoxDot desde el Índice de paquetes de Python usando pip desde su línea de comandos (línea de comandos en Windows, terminal en MacOS y Linux) ejecutando: </p>
								
                               <hr style= "border-color: #4e7c5c; width:90%">
									<h3> Linux </h3>

<p> Para linux puedes utilizar este <em> <a href=" https://github.com/Noisk8/InstalandoFoxDot-En-linux" target="_blank"> script</a> para agilizar el proceso de instalación. Recuerda ver las notas del repositorio para ver todos los componentes de instalación </em></p>									
								
<hr style= "border-color: #4e7c5c; width:90%">
	<h3> Windows </h3>
	
								<p> 1 Descargar <em> <a href="https://supercollider.github.io/download " target="_blank"> SuperCollider </a> En una versión superior a la 3.7</em></p>	
								
								<p> 2 Descargar <em> <a href=" https://www.python.org/downloads/windows" target="_blank"> Python </a> en lo posible MSI instaler (para chekar que incluye pip)</em></p>	
								
								<p> 3 instalar FoxDot vía CMD</p>

<p> 3.1 Abrimos CMD</p>
                       <img src="img/1.png" alt="FoxDot">	
                       
                    <p> 3.2  Accedemos a la carpeta donde estan ubicados los scripts de python </p> 
                       
                       <img src="img/3.png" alt="FoxDot" >
                       
                       	<p>3.3 Instalamos pip  </p>
                       
					   <img src="img/4.png" alt="FoxDot" >
					   
					   <p> 4 Descargar <em> <a href=" https://git-scm.com/download/win" target="_blank"> Git </a> esto para poder instalar posteriormente los quarks en supercollider</em></p>	
					   
					<hr style= "width:75%">   
					  <h3> Mac OS </h3>
					  
					  <p> 1 Descargar <em> <a href="https://supercollider.github.io/download " target="_blank"> SuperCollider </a> En una versión superior a la 3.7</em></p>
					 	<p> 2 Descargar <em> <a href="https://www.python.org/downloads/mac-osx/" target="_blank"> Python 2.7</a>  o superior </em></p>
					 	
					 			
										 	<p> 3 Descargar <em> <a href=" https://git-scm.com/download/mac" target="_blank"> Git</a> esto para poder instalar posteriormente los quarks en supercollider </em></p>
										 	
					 	<p> 4 Instalar pip </p>	 
					 	
					 	<p> 4.1 descargamos el script get_pip | Abrimos la terminal y ejecutamos el comando </p>
					 	
					 	<p><code> curl -O https://bootstrap.pypa.io/get-pip.py </code></p>
					 	
					 	<p> 4.2 ejecutamos el scrip con el comando </p>

					<p>	<code> python get-pip.py </code>	</p>
						
						<p> 5 instalar FoxDot con el siguiente comando </p>

								<p><code> sudo pip install FoxDot </code></p>

<p> 6 descargar el repositorio de Foxdot de github e instarlo  </p>	

<p><code> git clone https://github.com/Qirky/FoxDot.git </code> </p>		

<p> 6.1 entramos a la carpeta de FoxDot e instalamos FoxDot </p>	

<p><code>  cd FoxDot </code></p>

<p><code>  sudo python setup.py install </code> 	</p>	
								
								
<hr style= "border-color: #4e7c5c; width:90%">
								<h5> Para todas las plataformas </h5>
								
								<p> Despues de tener Supercollider, python y pip procedemos a abrir supercollider y de a una ejecutamos (shift + enter ) las siguientes lineas </p>
								
								<p><code> Quarks.install("https://github.com/Qirky/FoxDotQuark.git") </code></p>
								<p><code> Quarks.install("https://github.com/supercollider-quarks/BatLib.git") </code></p>
<hr style= "width:75%">
<h3> Cómo empezar? </h3>
                                
                             <h4>Linux</h4>
                            <p> Para linux sigue las instrucciones del <em> <a href=" https://github.com/Noisk8/InstalandoFoxDot-En-linux" target="_blank"> Repositorio</a>  </em></p>									
<hr style= "width:75%">
                            <h4> Windows </h4>

                            <p> 1 Abre Supercollider </p>

                            <p> 1.2 Ejecuta (shift + enter) el siguiente comando </p> 

                                                            <p><code> FoxDot.start </code></p>

                            <p> 2 abre el cmd y dirigete hasta la carpeta de python </p>

                            <p> 2.1 ejecuta <code>python -m FoxDot </code> </p>

                            <img src="img/5.png" alt="FoxDot" >

<hr style= "width:75%">

                                <h4> Mac OS </h4>			
                                                    <p> 1 Abre Supercollider </p>

                            <p> 1.2 Ejecuta (shift + enter) el siguiente comando </p> 

                        <p>    <code> FoxDot.start </code></p>

                            <p> 2 Abre una terminal y dirigete hasta la carpeta donde clonaste el repositorio de FoxDot </p>

                           <p> <code> cd FoxDot/ </code></p>

                            <p> 2.1  ejecuta python -m FoxDot </p>	

                          <p>  <code> python -m FoxDot</code></p>

                            <h3> Ejecutando lineas en FoxDot </h3>

                            <p> para hacer sonar  cualesquier linea de código en FoxDot solo basta con presionar shift + enter sobre la linea deseada </p>		
								
							</div>
						</div>
					</div>
					<div class="bb-item" id="item3">
						<div class="content">
							<div class="scroller">
								<h2>Haciendo tus primeros sonidos </h2>
<h3> Abriendo el editor de FoxDot </h3>

<p> Felicidades por haber instalado FoxDot - ¡hagamos algunos sonidos! Primero necesitas abrir SuperCollider para que podamos cargar los sonidos de FoxDot. Una vez que se abra SuperCollider, escriba lo siguiente en el editor: </p>

<p><code> FoxDot.start </code></p>

<p>Siga las instrucciones de instalación para sus descargas de Python y SuperCollider. Para ejecutar esta línea de código es necesario colocar el cursor de texto en la línea y presionar Ctrl+Return. La línea debería parpadear y debería ver que algunos números se vuelven verdes en la parte inferior de su pantalla:  </p>

<img src="http://docs.foxdot.org/wp-content/uploads/2018/03/sc_bootup.png" >

<p> Ahora podemos abrir el editor FoxDot y empezar a hacer sonidos. Puede abrir el editor yendo a su aplicación de línea de comandos (Símbolo del sistema en Windows, Terminal en Mac y Linux), escribiendo el siguiente código y presionando enter:</p>

<p> python -m FoxDot</p>

<p> Esto le indica a su computadora que ejecute el intérprete de Python y el módulo FoxDot como un script independiente. Usted debe ser recibido con una ventana que se ve algo como esto:</p>

<img src="http://docs.foxdot.org/wp-content/uploads/2018/03/foxdot_editor.png">

<h3> Evaluando Código</h3>
<p>Lo que tienes aquí es un editor de texto interactivo; puedes escribir código pero también ejecutar el código dentro del propio editor. Para ejecutar un bloque de código (líneas no separadas por líneas en blanco) asegúrese de que su cursor de texto está en el bloque de código que desea evaluar y presione Ctrl+Enter en Windows/Linux o Comando+Return en Mac. El texto debería parpadear en rojo por un momento y ser impreso en la consola en la parte inferior de la pantalla: <p>

<img src="http://docs.foxdot.org/wp-content/uploads/2018/03/foxdot_editor_exec.png">

<h3> Crea un ruido </h3>

<p>Hagamos un simple bucle de punteo. Escriba lo siguiente en el editor de FoxDot y evalúelo: <p>

<p></p><code> p1 >> pluck() </code></p>

<p>Esto debería iniciar un bucle muy básico reproduciendo una nota punteada al repetir. Para detener esto, agregue .stop() al final de la línea para que se vea así: </p>
<code> p1 >> pluck().stop()</code>
<p> Evalúe la línea para detener el bucle. ¡Ahí lo tienes! Has hecho sonido con FoxDot - echa un vistazo al resto de la sección "Getting Started" para familiarizarte con otros aspectos del entorno antes de pasar a las secciones avanzadas... ¡y diviértete!</p>

							

						</div>
						</div>
					</div>
					<div class="bb-item" id="item4">
						<div class="content">
							<div class="scroller">
								<h2>Introducción objeto reproductor </h2>
                                <h3> Eligiendo un sonido </h3>
                                
                                <p>Cuando FoxDot arranca, reserva todos los nombres de variables en minúsculas dos caracteres, por ejemplo, aa, p1 y bd, para utilizarlos como "reproductores". Estos son los objetos que tocan sonidos para nosotros basados en las instrucciones que les damos. La primera instrucción que le damos es decirle qué instrumento (sintetizador) tocar. Para ver una lista de todos los sintetizadores disponibles, evalúe lo siguiente:</p>
								
                                <code>print(SynthDefs)</code>
                                
                                <p>Es la abreviatura de Synth Definition. Elige uno y asígnalo a un objeto de reproductor FoxDot usando dos signos "mayor que", también conocido como "flecha doble". Si mi SynthDef elegido fuera "pluck" y mi objeto de jugador elegido fuera p1, entonces asignaría "pluck" a p1 así:</p>
                                
                                <p><code> p1 >> pluck()</code></p>
                                
                                <p> Asegúrese de incluir los corchetes al final de "pluck" o no funcionará. Para detener un objeto de reproductor individual, simplemente ejecute<code> p1.stop()</code> Para detener todos los objetos del reproductor, puede presionar Ctrl+. que es un acceso directo para el comando <code> Clock.clear()</code></p>
                                    <hr style= "border-color: #4e7c5c; width:90%">
                                
                                <h3>Asignando instrucciones</h3>
                                
                                <p> El >> en Python se suele reservar para un tipo de operación, como por ejemplo cómo se usa un símbolo `+' para añadir, pero no es el caso en FoxDot, y la razón se aclarará en breve. Añadiendo argumentos en los corchetes, puede cambiar las notas que se están reproduciendo. El primer argumento, el tono de la nota (a veces llamado grado), no necesita ser nombrado explícitamente, pero necesitará especificar otros atributos (como la duración) si desea cambiarlos. Estos valores pueden ser un valor individual o una lista de valores que el jugador jugará sucesivamente. Por ejemplo, el código de abajo toca tres notas seguidas continuamente hasta que se detiene p1:</p>
                                
                             <p>   <code>p1 >> pluck([0, 2, 4], dur=[1, 1/2, 1/2], amp=0.75)</code></p>
                                
                                <p> El primer argumento es el tono de la nota que queremos tocar, que es una lista de 3 números; 0, 2 y 4. El reproductor jugará cada uno de ellos por turno. Por defecto, todos los reproductores usarán la escala C-Major, que podemos considerar como una lista Python:</p>
                                
                               <p> <code> CMajor = [C, D, E, F, G, A, B]</code></p>
                                
                                <p> Los números que usamos para la afinación se refieren al índice de las notas que queremos escoger de esta escala. Entonces, con nuestra lista de lanzamientos[0, 2, 4] nuestras notas serían:</p>
                                
                              <p>  <code>CMajor[0] => C </code></p>
                               <p> <code> CMajor[2] => E </code></p>
                             <p><code>   CMajor[4] => G  </code></p>
                                
                                <p>La duración de estas notas se derivan del argumento dur palabra clave, que es también una lista de tres números; 1, 1/2 y 1/2. La posición de estos valores se refiere a la posición de los valores que hemos suministrado para el paso. Así que la primera nota durará un tiempo y las dos notas siguientes durarán la mitad de un tiempo. El último argumento de la palabra clave, amp, se utiliza para establecer la amplitud (volumen) de la nota, donde 0 es silencioso y 1 es más alto. Podrás encontrar otras palabras clave que puedes usar en la sección Atributos de los reproductores. </p>

<p>También puede agregar valores al Reproductor para crear variaciones en las secuencias o incluso reproducir acordes. Por ejemplo, el código de abajo se reproducirá cada 3 notas 4 tonos más alto:</p>
                                
                              <p>  <code> p1 >> pluck([0, 1, 2, 3], dur=2) + [0, 0, 4]</code></p>
                                <p> Para crear acordes, utilice una tupla en lugar de una lista. El código de abajo añadirá una tríada básica a cada nota tocada:</p>
                               <p> <code>p1 >> pluck([0, 1, 2, 3], dur=2) + (0, 2, 4)</code></p>
                                
                                    <hr style= "border-color: #4e7c5c; width:90%">
                                
                                <h3> Reproduciendo Samples </h3>
                               
                                <p> FoxDot también puede reproducir muestras de audio, como percusión, usando un SynthDef especial llamado play. En lugar de tomar una lista de números como primer argumento, toma una cadena de caracteres donde cada carácter se relaciona con un sonido diferente. He aquí un ejemplo de un patrón de batería muy básico:</p>
                                
                             <p>   <code> d1 >> play("x-o-")</code></p>
                                
                                <p> La cadena también puede contener información sobre cómo debe reproducirse la secuencia, lo que se hace utilizando diferentes tipos de paréntesis. Poner dos o más caracteres entre corchetes redondos alternará qué sonido reproducir en cada bucle a través de la secuencia:</p>
                                
                              <p>  <code> d1 >> play("(x-)(-x)o-") </code></p>
                                
                                <p> Poner varios caracteres entre corchetes los reproducirá sucesivamente en un solo paso. Este ejemplo interpreta un trillizo de hi-hats durante su cuarto paso:</p>
                                
                              <p>  <code> d1 >> play("x-o[---]", dur=1)</code></p>
                                
                                <p> También puede utilizar frenos rizados para elegir un sonido al azar, para añadir un poco de variedad a su secuencia:</p>
                                
                              <p>  <code> d1 >> play("x-o{-=*}")</code></p>
                                
                                <p> Todos estos pueden ser usados y anidados juntos para crear patrones complejos:</p>
                                
                             <p>   <code> d1 >> play("(x[--])xo{-[--][-x]}")</code></p>
                                
                                
                                
							</div>
						</div>
					</div>
					<div class="bb-item" id="item5">
						<div class="content">
							<div class="scroller">
								<h2>Patrones basicos</h2>
								
							<h3> Cómo usar patrones</h3>
                            <p> Los objetos del reproductor utilizan listas Python, a menudo conocidas como arrays en otros lenguajes de programación, para crear secuencias de valores, como afinación y duración. Sin embargo, las listas no son las estructuras de datos más intuitivas para las transformaciones. Por ejemplo, trate de multiplicar una lista - ¿qué sucede?</p>
                                
                            <p>    <code>print([1, 2, 3] * 2)</code></p>
                                
                                <p>El resultado es la misma lista repetida dos veces! Si quieres manipular los valores internos (por ejemplo, duplicarlos) en Python, puedes hacerlo de la siguiente manera:</p>
                                
                                <p> <code> values = [1, 2, 3]</code></p>
 
                            <p><code># Use a loop</code></p>
                              <code>  my_list = []</code>
                               <code> for i in values:</code>
                              <code>      my_list.append(i * 2)</code>
                               <code> print(my_list)</code>

                                <p><code> # List comprehension</code></p>
                                <p>  <code> print([i*2 for i in values])
                                
                                </code></p>

                                <p> Para ambos métodos, requiere tener que recorrer en bucle todos los valores y multiplicar cada uno individualmente. Las cosas se complican aún más si también quieres multiplicar cada segundo valor por un número diferente. Esto requiere bastante trabajo, especialmente si no sabes qué números vas a usar. Aquí es donde entra la clase de Patrones. </p>

<p> Los patrones actúan como las listas regulares de Python pero cualquier transformación matemática que se realice en ellas se hace a cada ítem de la lista. La forma más sencilla de crear un patrón es añadir una "P" mayúscula al comienzo de una lista:</p>
                                
                            <p>    <code>
                                    my_list    = [0, 1, 2, 3]</code></p>
                              <p>  <code> my_pattern = P[0, 1, 2, 3]
                                </code></p>
                                
                                <p>Ahora, cuando realice una operación, como una multiplicación, obtendrá el patrón transformado:</p>
                                
                                <code>print(my_pattern * 2)</code></p>
                               <p><code> P[0, 2, 4, 6]
                                </code></p>
                                
                                <p> También puede crear un patrón como lo haría con cualquier otro objeto Python usando el nombre de la clase seguido de corchetes con argumentos:</p>
                                
                               <p> <code>my_pattern = Pattern([0, 1, 2, 3])</code></p>
                                
                                <p> Los patrones también son "modulo indexable" lo que significa que no importa qué valor usemos como índice cuando accedemos a los datos de un Patrón, siempre y cuando sea un entero obtenemos un valor devuelto. Si el índice es mayor que la longitud del Patrón, entonces volvemos al principio del Patrón y empezamos a buscar:</p>
                                
                            <p><code> pat = P[0, 1, 2]</code></p>
                            <p><code>print(pat[2])</code></p>
                           <p><code> 2</code></p>
                              <p> <code> print(pat[3])</code></p>
                             <p><code>   0</code></p>
                                
                                <h3> Transformaciones </h3>
                                <p> Puede realizar una operación sobre un patrón utilizando una lista u otro patrón para crear transformaciones más complejas. Por ejemplo, sumando los patrones <code>P[0, 1, 2, 3] </code> y <code>P[4, 7] </code>se realizará la operación, lo que significa que el patrón resultante será el resultado <code>P[0 + 4, 1 + 7, 2 + 4, 3 + 7]</code> que es <code> P[4, 8, 6, 10]</code> El uso de patrones de longitudes sin divisor común creará un nuevo patrón que contiene todos los valores de las combinaciones:</p>
                                
                            <p> <code> >>> P[0, 1, 2, 3] + P[4, 5, -2]</code></p>
                              <p><code>  P[4, 6, 0, 7, 5, -1, 6, 8, -2, 5, 7, 1]</code></p>
                                
                                <p> Los patrones también tienen métodos específicos para la transformación, como <code> rotar, invertir y clasificar,</code>  que pueden utilizarse para manipular el orden:</p>
                                
                                <code>
                                >>> P[4, 1, 3, 2].rotate()
                                P[1, 3, 2, 4]
                                >>> P[4, 1, 3, 2].reverse()
                                P[2, 3, 1, 4]
                                >>> P[4, 1, 3, 2].sort()
                                P[1, 2, 3, 4]
                                </code>
                                
                                
                                <p> Puede evaluar <code>help(Pattern)</code> para ver más información sobre los métodos.</p>
                                
                                <h3> Funciones del patron</h3>
                                
                                <p> Hay una serie de funciones que devuelven diferentes Patrones. Estos generan Patrones más largos usando sólo unos pocos argumentos. Para ver una lista de funciones de Patrón, puede evaluar la ayuda (Patrones.Secuencias). En Python, puedes generar un rango de enteros con el rango de sintaxis (inicio, parada, paso). Por defecto, el inicio es 0 y el paso es 1. Puede utilizar PRange (inicio, parada, paso) para crear un objeto Pattern con los valores equivalentes:</p>
                                
                                <code>
                                 >>> print(list(range(0, 10 2)))
                                [0, 2, 4, 6, 8]
                                >>> print(PRange(0, 10, 2))
                                P[0, 2, 4, 6, 8]
                                 </code>
                                
                                <p> Y debido a que estas instancias de retorno de Patrón podemos tratarlas como objetos de Patrón y usar métodos de Patrón y realizar operaciones aritméticas sobre ellas así:</p>
                                
                                <code> 
                                    print(PRange(0, 10, 2).reverse() + [1, 2])
                                    P[9, 8, 5, 4, 1, 10, 7, 6, 3, 2]
                                </code>
                                
                                <h3> Concatenando Patrones </h3>
                                
                                <p> En Python, normalmente se concatenan dos listas (se agrega una a otra) usando el operador + pero ya hemos visto que haciendo esto con Patterns se añaden los valores de un patrón a los contenidos de otro. Para concatenar dos objetos Pattern juntos, puede usar el símbolo pipe, |, con el que los usuarios de Linux pueden estar familiarizados - se usa para conectar programas de línea de comandos enviando salida de un proceso como entrada a otro.</p>
                                
                                <code>  print(PRange(4) | [1,7,6])
                                        P[0, 1, 2, 3, 1, 7, 6]
                                </code>
                                
                                <h3> Cordones de patrones y PGroups </h3>
                                
                                <p>¿Qué sucede cuando un Patrón contiene una lista anidada como ésta?</p>
                                
                                <code> >>> pat = P[0, 2, [3, 5]]
                                        >>> print(pat)
                                        P[0, 2, P[3, 5]]
                                </code>
                                
                                <p> En primer lugar, la lista anidada se convierte en un patrón (y cualquier lista anidada que pudiera contener también se convierte). Si intentamos acceder al patrón anidado aquí es lo que pasa:</p>
                                
                                <code>
 
                                print(pat[0])
                                0
                                print(pat[1])
                                2
                                print(pat[2])
                                3
                                </code>
                                
                                <p> ¿Eso es extraño...? Se te perdonaría por pensar que la última línea devolvería P[3, 5] porque ese es el objeto en la tercera ranura de la palmadita, pero no es así como se comportan los Patrones. Los patrones están entrelazados, lo que significa que los valores de los patrones anidados se devuelven cuando se accede a su patrón padre. Para acceder al segundo valor del patrón anidado en el ejemplo anterior necesitamos hacer un bucle a través del Patrón por segunda vez, es decir, usar un valor de índice mayor que la longitud del Patrón:</p>
                                
                                <code>  for i in range(6):
                                          print(pat[i],)
                                        0, 2, 3, 0, 2, 5
                                
                                </code>
                                
                                <p> Debido a esto, cuando imprima la longitud de un Patrón, verá el tamaño del Patrón como si estuviera expandido como está arriba. Si usas paréntesis redondos y anidas una tupla de valores, verás que sucede algo muy diferente:</p>
                                
                                <code> >>> pat = P[0, 2, (3, 5)]
                                        >>> print(pat)
                                        P[0, 2, P(3, 5)]
                                </code>
                                
                                <p> El último ítem en el patrón se conoce como un PGroup y se usa para mantener los valores dentro de un patrón juntos, es decir, no enlazados:</p>
                                
                                <code> >>> print(pat[0])
                                        0
                                        >>> print(pat[1])
                                        2
                                        >>> print(pat[2])
                                        P(3, 5)
                                </code>
                                
                                <p> Agrupar valores significa que se tocan al mismo tiempo y esto es muy útil cuando se desea tocar notas juntos, por ejemplo, acordes:</p>
                                
                                <code> p1 >> pluck([(0, 2, 4), (0, 3, 5)], dur=4) </code>
                                
                                <p> Puede agregar tuplas/ PGrupos a un Patrón para crear un nuevo patrón de elementos de PGrupo:</p>
                                
                                <code> >>> pat = P[0, 3, 5, 4]
                                        >>> print(pat + (0, 2))
                                        P[P(0, 2), P(3, 5), P(5, 7), P(4, 6)]
                                        >>> print(pat + [(0, 2), (2, 4)])
                                        P[P(0, 2), P(5, 7), P(5, 7), P(6, 8)]
                                </code>
                                
                                
                                
							</div>
						</div>
					</div>
					<div class="bb-item" id="item6">
						<div class="content">
							<div class="scroller">
							<h2>Variables dependientes del tiempo</h2>
							<h3>Programación a tiempo </h3>
								<p>Cuando usted está codificando música en vivo, a menudo querrá que las cosas cambien con el tiempo. Una buena manera de demostrar esto es usando secuencias de acordes. Digamos que tenemos la secuencia C-F-C-G, que podemos representar como la lista de Python <code>[0, 3, 0, 4]</code>, y queremos tocar los acordes para 8 tiempos cada uno pero con un jugador que esté tocando notas cada cuarto de compás. ¿Cómo lo hacemos? Una solución podría ser usar el método del Patrón tartamudeo que repite valores en un Patrón "n" veces:  </p>
                                
                                <code>print(P[0, 3, 0, 4].stutter(4) + (0, 2, 4)) </code>
                                <code>P[P(0, 2, 4), P(0, 2, 4), P(0, 2, 4), P(0, 2, 4), P(3, 5, 7), P(3, 5, 7), P(3, 5, 7), P(3, 5, 7), P(0, 2, 4), P(0, 2, 4), P(0, 2, 4), P(0, 2, 4), P(4, 6, 8), P(4, 6, 8), P(4, 6, 8), P(4, 6, 8)]</code>
                                
                                <p> Así que para tocar la secuencia de acordes de arriba con un sonido "pluck" podríamos hacer algo como esto:</p>
							
                                <code> p1 >> pluck(P[0, 3, 0, 4].stutter(32), dur=1/4) + (0, 2, 4) </code>
                                
                                <p> Con 4 notas por compás y 8 tiempos por acorde podemos deducir fácilmente que necesitamos tartamudear cada valor de tono 32 veces. El problema es que tenemos que cambiar ese valor cada vez que cambiamos la duración. Si cambiamos nuestra duración a <code>[1/2, 1/4, 1/4, 1/4]</code> necesitaríamos hacer algunas matemáticas en nuestra cabeza (o usar Python) para calcular cuántas veces tartamudear los valores de la afinación. Para evitar esto podemos usar variables que cambian su valor con el tiempo, así que después de 8 tiempos automáticamente empezamos a tocar un tono diferente. Estas son conocidas como "variables dependientes del tiempo" o "TimeVar" para abreviar.</p>
                                <p> Un TimeVar tiene una serie de valores entre los que cambia después de un número predefinido de latidos y se crea usando un objeto var con la sintaxis <code> var([lista_de_valores],[lista_de_duraciones]) </code> Ejemplo:</p>
                                    
                                    <code>  >>> a = var([0,3],4)             # Duration can be single value
                                            >>> print(int(Clock.now()), a)   # 'a' initially has a value of 0 when 0 beats have elapsed
                                            0, 0
                                            >>> print(int(Clock.now()), a)   # After 4 beats, the value changes to 3
                                            4, 3
                                            >>> print(int(Clock.now()), a)   # After another 4 beats, the value changes back to 0
                                            8, 0  </code>


 								<p> Así que para resolver nuestro problema original con la reproducción de una secuencia de acordes, podríamos utilizar el siguiente código con cualquier valor de duración y todavía aquí la secuencia de juego de 8 tiempos por acorde: </p>


								<p> Así que para resolver nuestro problema original con la reproducción de una secuencia de acordes, podríamos utilizar el siguiente código con cualquier valor de duración y todavía aquí la secuencia de juego de 8 tiempos por acorde:</p>
                                
                                <code> p1 >> pluck(var([0, 3, 0, 4], 8), dur=[1,1/4,1/4,1/2]) + (0, 2, 4) </code>
                                
                                <h3> Transformando Timevars</h3>
                                <p> Cuando se utiliza una operación matemática en una variable, se devuelve una nueva variable que también cambia su valor con el tiempo:</p>
                                
                                <code>  >>> a = var([0,3], 4) </code>
                                <code>     >>> b = a + 5 </code>
                                <code>     >>> print(a, b)        # Current time = 0 </code>
                                   <code>     0, 5 </code>
                                <code>   >>> print(a, b)        # beat = 4 </code>
                                <code>  3, 8 </code>
                                <code>      >>> c = PRange(4) + a</code>
                                 <code>       >>> print(c)           # beat = 8 and 'a' has a value of 0 </code>
                                <code>       P[0, 1, 2, 3] </code>
                                <code>        >>> print(c)           # beat = 12 and a has a value of 3 </code>
                                 <code>       P[3, 4, 5, 6]
                                </code>
                                  <hr style= "border-color: #4e7c5c; width:90%">
                                <h3> Cambio continuo</h3>
                                
                                <p> Hasta ahora sólo hemos visto un TimeVar tomar uno de un conjunto de valores predefinidos, pero también hay tipos de TimeVar que gradualmente cambian entre sus valores con el tiempo. Un ejemplo de ello es la <code>linvar</code>. Esto es instanciado de la misma manera que un var pero el valor cambia linealmente entre estados con el tiempo. El ejemplo de abajo mueve el panoramizado de izquierda a derecha a lo largo de 8 tiempos y luego de nuevo hacia atrás.</p>
                                
                                <code> p1 >> pluck(dur=1/4, pan=linvar([-1,1],8)) </code>


							</div>
					</div>
					</div>
					<div class="bb-item" id="item7">
						<div class="content">
							<div class="scroller">
								<h2>Atributos del reroductor</h2>

                                <h3>Introducción </h3>

                                <p> A los objetos del reproductor FoxDot se les asignan sintetizadores que toman varios argumentos de palabras clave en un conjunto de corchetes para manipular las secuencias que se están reproduciendo. Probablemente ya hayas visto <code>Dur</code> y <code> Pan</code>, pero ¿qué más podemos usar? Hay muchas opciones, que se dividen en dos grupos: atributos y efectos. Los atributos son cosas que afectan qué nota se toca y cuándo y los efectos son cosas que cambian cómo suena el sonido, bueno, ¡suena! Puede ver una lista de todos los posibles términos de palabras clave evaluando el código</p>
                                
                                <code>print(Player.get_attributes())</code>
                                <code>('degree', 'oct', 'dur', 'delay', 'blur', 'amplify', 'scale', 'bpm', 'sample', 'sus', 'fmod', 'pan', 'rate', 'amp', 'vib', 'vibdepth', 'slide', 'sus', 'slidedelay', 'slidefrom', 'bend', 'benddelay', 'coarse', 'striate', 'pshift', 'hpf', 'hpr', 'lpf', 'lpr', 'swell', 'bpf', 'bpr', 'bits', 'amp', 'crush', 'dist', 'chop', 'tremolo', 'echo', 'decay', 'spin', 'cut', 'room', 'mix', 'formant', 'shape')</code>
                                
                                <p>Tenga en cuenta que un SuperCollider <code>SynthDef</code> puede tomar argumentos de palabras clave específicos que no están en la lista anterior. Puedes establecer los valores para un atributo o efecto de un reproductor especificándolos como un argumento de palabra clave dentro de una llamada de SynthDef:</p>
                                
                                <code>p1 >> pluck([0, 1, 2, 3], dur=1/2, sus=2)</code>
                                  <hr style= "border-color: #4e7c5c; width:90%">

                                <h3>Atributos</h3>
                                
                                <p>Estos son los valores de las palabras clave que FoxDot utiliza para decidir qué nota o muestra se reproducirá en cada momento. Sin ningún orden en particular: <code> degree, oct, dur, scale, amp, amplify, bpm, sample, and delay.</code> Vamos a repasar cada uno de estos en profundidad con algún código de ejemplo ahora.</p>
                                
                                <h4>degree</h4>
                                <p>Esto a veces se denomina "tono" y se refiere al índice de la escala que debemos utilizar para crear una nota - así que para tocar la primera nota de una escala, se utiliza el valor de grado 0. No es necesario especificar este por nombre ya que es siempre el primer argumento utilizado. Aquí hay un código de ejemplo que reproduce las primeras cuatro notas de la escala por defecto (Do mayor).</p>
                                
                                
                                
                                <p> p1 >> pluck([0, 1, 2, 3])</p>
                                
                                  <hr style= "border-color: #4e7c5c; width:90%">
                                
                                <h4> oct</h4>
                                
                                <p> Esta es la octava en la que desea tocar una nota. Por defecto es 5, de modo que la nota que se toca al iniciar un objeto de jugador "en blanco" es la C media. Una octava es (normalmente) 12 semitonos, por lo que la quinta octava comienza en el 60º semitono. Añadimos este valor a nuestra afinación (que obtenemos al usar el grado para obtener el valor final de la nota. Un número más pequeño toca una nota más baja y un número más grande toca una nota más alta:</p>
                                
                                <code>p1 >> pluck(oct=[4, 5, 6])</code>
                                
                                  <hr style= "border-color: #4e7c5c; width:90%">
                                
                                <h4> dur </h4>
                                
                                <p>Es la duración de una nota. Las duraciones no pueden ser negativas y deben contener al menos un número distinto de cero. Una duración puede ser de cualquier tipo siempre y cuando pueda ser representada por un valor de coma flotante. Las siguientes son todas las duraciones válidas:</p>
                                
                                <code> # Valor individual para todas las notas </code>
                                <code>     p1 >> pluck([0, 1, 2, 3], dur=1/2) </code>

                                <code>    Una lista de duraciones puede ser números enteros, fracciones o valores de coma flotante. </code>
                                    <code>   p1 >> pluck([0, 1, 2, 3], dur=[1,1/2,0.5])</code> 

                                  <code>      p1 >> pluck([0, 1, 2, 3], dur=[0.1,0.3,0.43,0.17])</code> 
                               
                                
                                <p>Puede "saltar" una nota poniendo la duración a cero o "silenciándola" utilizando un objeto de <code> rest</code> reposo con la duración entre paréntesis:</p>
                                
                                <code>  # Salta cada tercera nota </code>
                                  <code>      p1 >> pluck([0, 1, 2, 3], dur=[1, 1, 0])</code> 

                                     <code>   # Descansa cada tercera nota por 2 tiempos</code> 
                                     <code> p1 >> pluck([0, 1, 2, 3], dur=[1, 1, resto(2)])  </code>
                                
                                  <hr style= "border-color: #4e7c5c; width:90%">
                                
                                <h4>Escala </h4>
	                           <p>Como su nombre indica, esto establece la escala del objeto del jugador. Debe ser una lista, un Patrón o un objeto Escala (que es una subclase de Patrón). Para ver una lista de escalas, puede evaluar el siguiente código:</p>
                                
                                
                                <code> print(Scale.names()) </code>
                                <code>['aeolian', 'chinese', 'chromatic', 'custom', 'default', 'diminished', 'dorian', 'dorian2', 'egyptian', 'freq', 'harmonicMajor', 'harmonicMinor', 'indian', 'justMajor', 'justMinor', 'locrian', 'locrianMajor', 'lydian', 'lydianMinor', 'major', 'majorPentatonic', 'melodicMajor', 'melodicMinor', 'minor', 'minorPentatonic', 'mixolydian', 'phrygian', 'prometheus', 'romanianMinor', 'yu', 'zhi']</code>
                                
                                <p> Por defecto, FoxDot utiliza la escala "mayor". Para cambiar esto a la escala menor, por ejemplo, puede utilizar el argumento de la palabra clave de la escala y la escala Scale.minor así:</p>
                                
                                <code> # reproducir con la escala por defecto
                                        p1 >> pluck([0, 2, 4, 6, 7])

                                        # cambiar a menor
                                        p1 >> pluck([0, 2, 4, 6, 7], scale=Scale.minor)</code>
                                
                                <p> Si desea cambiar la escala para todos los reproductores, puede establecer el valor Escala.predeterminada:</p>
                                 <code>  # Iniciar un reproductor en la escala por defecto (Major) </code>
                                    <code>  p1 >> pluck([0, 2, 4, 6, 7])</code>

                                    <code>  # Cambia la escala por defecto a Dorian </code>
                                    <code>Escala.default = Escala.dorian </code>

                               <code> #Puede especificar la escala por defecto como una cadena </code>
                              <code>  Escala.default = "dorian"</code>
                                
                                  <hr style= "border-color: #4e7c5c; width:90%">
                                
                                <h3>amp</h3>
                                <p> Es la amplitud de una nota, o su volumen/volumen. Los valores normalmente oscilan entre 0 y 1, pero puede ajustar valores más grandes para que una nota sea aún más fuerte, pero tenga cuidado de no hacer demasiado ruido o podría dañarse los oídos o los altavoces. </p>
                                
                                <code> p1 >> pluck([0, 1, 2], dur=[1, 1/2, 1/2], amp=[1, 0.5, 1/3])</code>
                                
                            <p> Podemos crear patrones bastante rítmicos usando amplificador usando valores de 0 también:</p>
							
                            <code> p1 >> pluck(dur=1/4, amp=[1, 1/2, 1/2, 1, 0, 1, 0, 1, 1/2, 1/2, 1, 0, 1, 1/2, 1/4, 1])</code>
                                
                                <p> ¿Pero qué pasa si queremos tocar este ritmo en cualquier otro bar? Una forma podría ser añadir manualmente un montón de 0s a la secuencia o usar un objeto Pattern y usar su método de "stutter" tartamudeo, pero también podemos usar otro argumento de palabra clave diseñado para este propósito; amplificar.</p>
                                
                                <h3> amplifly </h3>
                                
                                <p> Antes de que un sonido sea disparado por un reproductor, el valor del amplificador se multiplica por amplificar para que puedas usar cosas como TimeVar para ajustar una amplitud a 1 o 0 (es decir, encendido y apagado) durante cierto tiempo:</p>
                                
                                <code> p1 >> pluck(dur=1/4, amp=[1, 1/2, 1/2, 1, 0, 1, 0, 1, 1/2, 1/2, 1, 0, 1, 1/2, 1/4, 1], amplify=var([1,0],[6,2])) </code>
                                
                                <p> Esto es útil si desea activar o desactivar varios reproductores al mismo tiempo:</p>
                            
                            <code> p1 >> pluck(dur=1/4, amp=[1, 1/2, 1/2, 1, 0, 1, 0, 1, 1/2, 1/2, 1, 0, 1, 1/2, 1/4, 1])</code> 
                                 <code>   p2 >> bass(var([0, 3], 8), dur=1/2)</code> 

                                  <code> p1.amplify = p2.amplify = var([1,0],4)</code>
                            
                                <p> The last line is quite clumsy so you can use a Group object in place (see here for more information):</p>
                            
                                <code> p1 >> pluck(dur=1/4, amp=[1, 1/2, 1/2, 1, 0, 1, 0, 1, 1/2, 1/2, 1, 0, 1, 1/2, 1/4, 1])</code> 
                                   <code> p2 >> bass(var([0, 3], 8), dur=1/2)</code> 

                                  <code>  Group(p1, p2).amplify = var([1,0],4)</code>
                                
                                <h3> bpm</h3>
                            
                                <p> Si desea que un objeto de reproductor se reproduzca a un tempo diferente, puede utilizar el atributo bpm. Estos son los latidos por minuto. El tempo del reloj de programación global se puede establecer cambiando su atributo bpm usando Clock.bpm = 140 por ejemplo (ver aquí para más información).</p>
                                
                                <code> # Reproduce en el tempo Clock.bpm (por defecto 120)</code>
                                <code>        p1 >> pluck([0, 1, 2, 3])</code>

                                    <code>    # Forzar al jugador a usar 100 bpm</code>
                                    <code>    p2 >> campana([4, 5, 7], bpm=100)</code>

                                      <code>  # Siempre se reproducirá a 100 bpm incluso si se cambia Clock.bpm</code>
                                       <code> Reloj.bpm = 200</code>
                                
                                <h3> sample </h3>
                                
                                <p> Esto sólo se usa con el reproductor de muestra, llamado play. Este SynthDef toma una cadena como su primer argumento (conocido como "play string") en lugar de una lista de valores de afinación y reproduce muestras de audio almacenadas en su portátil basándose en el carácter de la cadena. Cada carácter se asigna a una carpeta de muestras y, de forma predeterminada, reproduce la primera muestra de esa carpeta. Para reproducir una muestra diferente, utilice la palabra clave de muestra:</p>
                                
                                <code> 
                                
                                    # samples por defecto </code>
                                <code>  p1 >> play("x-o-") </code>

                                <code># Un conjunto diferente de samples </code>
                                <code>  p1 >> play("x-o-", sample=1) </code>

                                <code>   # Puede ser una lista de valores </code>
                               <code> p1 >> play("x-o-", sample=[0, 1, 2])</code>
                                
                                <p> Los valores deben ser enteros. Si una carpeta contiene 3 muestras y utiliza el valor 4, el objeto del reproductor volverá al primer archivo de la carpeta y reproducirá ese archivo, por lo que no necesita saber exactamente cuántas muestras hay en una carpeta.</p>
                                
                                <h3> delay </h3>
                                
                                <p> En la música (y especialmente en la música electrónica) el retardo se refiere a menudo a una especie de efecto "eco" en el que un sonido se reproduce de nuevo poco después de que comienza, pero un poco más silencioso. En FoxDot, sin embargo, se refiere literalmente a una cantidad de tiempo, en latidos, para retrasar la reproducción de un sonido. Aquí, retrasaremos cada tercera nota por medio tiempo:</p>
                            
                                
                                <code> p1 >> pluck([0, 1, 2, 3], delay=[0, 0, 0.5]) </code>
                            
                            
                            <p> Si quieres tocar la nota y tocarla con un retardo, puedes usar una tupla o un PGroup con el primer valor 0, lo que significa que no hay retardo. El segundo valor indicará cuánto tiempo debe demorarse la segunda nota: </p>
                                
                                <code> #"stutter" cada tercera nota </code>
                                <code>       p1 >> pluck([0, 1, 2, 3], delay=[0, 0, (0, 0.5)]) </code>

                                     <code>   # Retrasa una nota para tocar *después* de la siguiente</code>
                                      <code>  p1 >> pluck([0, 1, 2, 3], delay=[0, 0, (0, 1.5)])</code>
                                
                                
                            
                            </div>
								
								</div>
								
								</div>
	                <div class="bb-item" id="item8">
						<div class="content">
							<div class="scroller">
								<h2>Efectos del Reprodcor</h2>
                                              <p>Los efectos se pueden agregar a un Reproductor de la misma manera que se cambian sus atributos; utilizando argumentos de palabras clave. Al igual que con los atributos del Reproductor, pueden ser un único valor o una secuencia. Esta página contiene descripciones de los diferentes efectos disponibles en FoxDot y cómo aplicarlos. </p>
<p>
La mayoría de los efectos se aplican utilizando un único valor, como pan, pero algunos tienen un único efecto "padre" y uno o más efectos "hijo". Un ejemplo es slide, que es el padre, y slidedelay es el hijo. Si el efecto padre se establece en 0, el efecto no se aplica. Los valores hijo de 0 todavía se aplican si el padre es distinto de cero.</p>
                                <p><code> # Efecto de diapositivas añadido                   </code></p>
                              <p>  <code> p1 >> pluck(dur=4, slide=1, slidedelay=0.5)        </code></p>

                               <p> <code> # Efecto de diapositivas no añadido                </code></p>
                              <p>  <code> p1 >> pluck(dur=4, slide=0, slidedelay=0.5)        </code></p>

                               <p> <code> # Efecto de deslizamiento añadido, con retardo cero</code></p>
                               <p> <code> p1 >> pluck(dur=4, slide=1, slidedelay=0)          </code></p>
                               <hr style= "border-color: #4e7c5c; width:90%"> 
                                <h3>Sustain</h3>
                                <h5>palabras claves: sus, blur=1</h5>
                                <p>El argumento de la palabra clave sus se utiliza para establecer el "sustain" de una nota, lo que significa cuánto tiempo dura el sonido de la nota. Por defecto es la misma que la duración de la nota (ajustada con la palabra clave dur) y es un valor medido en términos de "beats". El siguiente código reproducirá una nota de un compás, una repetición con un sostenido de medio compás:</p>
                                
                               <p> <code># Duración de un latido, duración de medio latido</code></p>
                              <p>  <code>p1 >> pluck(dur=1, sus=1/2)                      </code></p>
                                
                                <p>Utilice el desenfoque 'blur' para crear un efecto de "legato" (una palabra que significa "atado" en italiano). Este es un término musical que se refiere a cómo las notas se suceden entre sí, o se desdibujan juntas. El valor sus se multiplica por el valor de desenfoque actual de tal manera que el siguiente código duplica la longitud del sustain de cada una de las otras notas:</p>
                                
                               <p><code># Duplica la longitud de cualquier otra nota </code></p> 
                               <p> <code>p1 >> pluck(dur=PDur(3,8), blur=[1, 2])</code></p> 
                               <hr style= "border-color: #4e7c5c; width:90%"> 
                                <h3>Stereo panning</h3>
								<h5>palabras clave: pan </h5>
                                <p>La panorámica (en audio) es la distribución del sonido a través de varios altavoces. Actualmente FoxDot sólo utiliza dos canales de salida (para el altavoz izquierdo y derecho) pero hay planes para expandirlo para múltiples altavoces. Para cambiar el panorama de un sonido, utilice el panorama y establezca el valor entre -1 (izquierda dura) y 1 (derecha dura). Un valor de panoramización de 0 envía la señal de audio de ambos altavoces por igual.</p>
                                
                               <p> <code># Alternar entre izquierda, centro y derecha</code></p>
							 	<p><code>p1 >> pluck(pan =[-1, 0, 1])</code></p>
                               <p> <code># Toca dos notas al mismo tiempo, pero en diferentes altavoces</code></p>
							 	<p><code>p1 >> pluck((0, 4), pan=(-1,1))</code></p>
                               <p> <code># Mueva gradualmente el sonido de izquierda a derecha usando una "linvar".</code></p>
							 	<p><code>p1 >> pluck([0, 2, 4, 7], dur=1/4, pan=linvar([-1,1],8))</code></p>
                                
                                <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>Frequency modifier</h3>
                                <h5>palabra clave: fmod</h5>
                                
                                <p>Esto añade un valor a la frecuencia utilizada para generar una nota, pero sólo en uno de los canales. Por ejemplo, al iniciar un reproductor sin instrucciones, se reproducirá continuamente una nota en el do medio, que es 261,6 Hz, a través de ambos canales de altavoz. Usando fmod = 10 reproducirá la nota a 261.6 Hz en un canal, y 271.6 Hz en el otro. Esto crea una notable "disonancia" o un sonido "atonal" debido a que las frecuencias están tan cerca unas de otras. Usando un valor más pequeño, como 2, crea una especie de efecto de flanger:</p>
                                
                               <p> <code># Simple efecto flanger                             </code></p>
                                <p><code>p1 >> pluck(fmod = 2)                               </code></p>
                                <p><code># Varía el efecto con el tiempo                     </code></p>
                               <p> <code>p1 >> pluck(fmod=linvar([-10,10],8), dur=1/4, sus=1)</code></p>
                               
                                <hr style= "border-color: #4e7c5c; width:90%">
                                <h3> vibrato</h3>
                                <h5>palabras clave: vib, vibdepth = 0.02</h5>
                                
                                <p>Vibrato es un término musical que se refiere a una modulación continua de la afinación, es decir, que cambia con el tiempo. Puedes establecer la velocidad del vibrato de una nota usando la palabra clave vib y la profundidad (el tamaño de la modulación) del vibrato usando la palabra clave vibdepth. La profundidad por defecto es de 0.02, lo que significa que el vibrato fluctúa entre +/- la frecuencia de la nota multiplicada por 0.02. También se puede pensar que fluctúa entre el 99% y el 101% del valor de frecuencia.</p>
                                
                              <p>  <code>p1 >> pads(dur=4, vib=4)               </code></p>
                              <p>  <code>p1 >> pads(dur=4, vib=4, vibdepth=0.1) </code></p>
                               <p> <code>p1 >> pads(dur=4, vib=4, vibdepth=1)   </code></p>
                                <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>silde</h3>
                                <h5> palabras clave: slide, slidedelay = 0</h5>
                                <p>Se utiliza para cambiar la frecuencia de una nota con el tiempo. La frecuencia "desliza" a (1 + n) * freq donde n es el valor suministrado a la palabra clave de la diapositiva. Por ejemplo, un valor de diapositiva de 1 desplazará la frecuencia hasta el doble de su valor original (una octava hacia arriba). Un valor de diapositiva de -1 se deslizará a una frecuencia de 0.</p>

                                <p> Por defecto, el efecto de diapositiva comienza inmediatamente después de que comienza la nota. Para retrasar el inicio de la diapositiva, puede utilizar la palabra clave slidedelay. Este debe ser un valor entre 0 (el comienzo de la nota) y 1 (el final de la nota).</p>
                                
                               <p> <code># Desliza una octava hacia arriba             </code></p>
                            <p>    <code>p1 >> pluck(dur=4, slide=1)                   </code></p>
                               <p> <code># Slide to 0                                  </code></p>
                            <p>    <code>p1 >> pluck(dur=4, slide=-1)                  </code></p>
                               <p> <code># Retrasa el efecto de la diapositiva para comenzar a mitad de la nota                                                </code></p>
                                <p><code>p1 >> pluck(dur=4, slide=0.5, slidedelay=0.5) </code></p>
                                <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>slide from </h3>
                                <h5>palabra clave: slidefrom, slidedelay = 0</h5>
                                <p>Similar a la diapositiva, este efecto también cambia la frecuencia de una nota con el tiempo, pero usted especifica dónde comienza la diapositiva. La frecuencia "desliza" desde (1 + n) * freq donde n es el valor suministrado a la palabra clave deslizante y termina en la frecuencia de la nota.</p>

                                <p>Por ejemplo, un valor de 1 desplazará la frecuencia desde el doble de su valor original (una octava hacia arriba). Un valor de diapositiva de -1 se deslizará desde una frecuencia de 0. Por defecto, el efecto de diapositiva comienza inmediatamente después de que comienza la nota. Para retrasar el inicio de la diapositiva, puede utilizar la palabra clave slidedelay. Este debe ser un valor entre 0 (el comienzo de la nota) y 1 (el final de la nota).</p>
                                
                             <p>   <code># Deslízate de una octava hacia arriba</code></p>
                            <p>    <code>p1 >> pluck(dur=4, slidefrom=1)       </code></p>
                               <p> <code># Slide from 0                        </code></p>
                            <p>    <code>p1 >> pluck(dur=4, slidefrom=-1)      </code></p>
                               <p> <code># Retrasa el efecto de la diapositiva para comenzar a mitad de la nota                                        </code></p>
                              <p>  <code>p1 >> pluck(dur=4, deslizamiento desde=0.5, deslizamiento retardado=0.5)                              </code></p>
                                <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>Pitch bend</h3>
                                <h5>palabras clave: bend, benddelay = 0</h5>
                                <p>Otro efecto similar al deslizamiento, el pitch bend cambia la frecuencia de una nota a lo largo del tiempo, pero también vuelve a su frecuencia original al final de la nota. Aparte de eso, funciona exactamente igual que la diapositiva.</p>
                                
                             <p>   <code># Dobla una octava hacia arriba y hacia atrás otra vez</code></p>
                             <p>   <code>p1 >> pluck(dur=4, bend=1)                            </code></p>
                               <p> <code># Bend to 0 and back again                            </code></p>
                               <p> <code>p1 >> pluck(dur=4, bend=-1)                           </code></p>
                               <p> <code># Retrasa el efecto de curvatura para empezar a mitad de la nota                                                               </code></p>
                               <p> <code>p1 >> pluck(dur=4, slide=0.5, bend=0.5)               </code></p>
                                
                                <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>chop</h3>
                                <h5>palabras clave: chop </h5>
                                <p>El "chops" la señal de audio en "n" partes, donde "n" es el valor que proporciona al argumento de la palabra clave. Utiliza el sustain de la nota (fijado con sus) para determinar el tamaño de las partes, por lo que también puede combinar chop y sus para crear efectos interesantes.</p>
                                
                               <p> <code># Cortar un sonido en 4 partes</code></p>
                              <p>  <code>p1 >> pluck([0,1,2,3], dur=4, chop=4)</code></p>
                              <p>  <code># Si la duración varía, el tamaño de la chuleta también variará</code></p>
                                
                                <p>Cambiar un único valor para "sus" iguala los tamaños y crea un bonito efecto de eco superpuesto.</p>
                                <code>p1 >> pluck([0,[4,6,7]], dur=PDur(3,8), chop=4, sus=2)</code>
                              
                                <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>coarse</h3>
                                <h5>palabras clave: coarse</h5>
                                <p>Esto es similar a "chop" pero difiere en que la señal de audio no está siendo "cortada", sino que la velocidad de control (la frecuencia de las notas / la velocidad de reproducción de las muestras). Esto puede ser útil en varias situaciones.</p>
                                <p>reproducción: El uso de chop esencialmente sólo reproduce la mitad del audio mientras que la otra mitad está siendo silenciada por el efecto "chop". Usando grueso esencialmente pausará el sonido y lo reanudará después de un ligero retraso. Esto lo hace ajustando la velocidad de reproducción a 0 mientras que chop ajustaría la amplitud a 0. Escuche la diferencia ejecutando el código de abajo en FoxDot:</p>
                                
                               <p> <code>#usando chop</code></p>
                              <p>  <code>c1 >> play("c", dur=4, chop=16, grosor=0)</code></p>
                               <p> <code>#usando gruesos</code></p>
                               <p> <code>c1 >> play("c", dur=4, grosor=16, chop=0)</code></p>
                                
                                <p>Otro uso para sonidos gruesos sería cuando se obtienen sonidos de "recorte" al usar chop. Esto ocurre cuando una amplitud va a 0 muy rápidamente y suena como un pequeño "pop". Ejecute estas líneas de código en FoxDot y escuche las diferencias:</p>
                                
                               <p> <code>b1 >> bass(dur=2, chop=4,coarse=0)</code></p>

                               <p> <code>b1 >> bajo(dur=2, coarse=4, chop=0)</code></p>


 
                                <p>
                                    La línea que usa tosca = 4 suena un poco más limpia. Desafortunadamente esto no siempre sucede y lo grueso no siempre se puede aplicar a algunos sintetizadores, por ejemplo klank.</p>
                                <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>Filtro de pasos altos</h3>
                                <h5> palabras claves:  hpf, hpr = 1</h5>
                                <p>Un sonido no trivial se compone de una combinación de ondas sonoras que vibran a varias frecuencias y amplitudes, y algunas de ellas pueden "filtrarse" de una señal utilizando un filtro. Esto se conoce a menudo como "síntesis sustractiva". Un filtro de paso alto eliminará las partes de una señal que están por debajo de cierta frecuencia, es decir, sólo permite el paso de frecuencias superiores al umbral. Esto se puede aplicar en FoxDot simplemente ajustando el valor hpf (abreviatura de filtro pasaaltos):</p>
                                
                            <p>    <code>#Ajuste el límite del filtro pasa-altos a 2000 Hz.</code></p>
                             <p>   <code>d1 >> play("x-o-", hpf=2000)                      </code></p>
                              <p>  <code># Establece el corte para que cambie con el tiempo usando una linvar                                                  </code></p>
                               <p> <code>d1 >> play("x-o-", hpf=linvar([0,2000],32)        </code></p>
                                
                                <p>También puede ajustar la resonancia de paso alto para el filtro usando la palabra clave hpr. Esto se denomina a veces "rq" o "hpq". A medida que este valor disminuye, los armónicos cerca del valor de corte se incrementan - un valor cercano a 0 sonará como una onda sinusoidal oscilando en el valor establecido usando hpf. Tenga cuidado con los valores muy pequeños y muy grandes ya que podría obtener sonidos muy fuertes!</p>
                                
                              <p>  <code>#Ajuste el límite del filtro pasa-altos a 2000 Hz.</code></p>
                               <p> <code>d1 >> play("x-o-", hpf=2000)</code></p>
                                
                              <p>  <code> Ajuste la resonancia a 0.2 - ¿puede oír la diferencia?</code></p>
                                <p><code>d1 >> play("x-o-", hpf=2000, hpr=0.2)</code></p>
                                
                              <p>  <code>#Ajuste la resonancia de corte *y* para que cambie con el tiempo usando linvar                              </code></p>
                                <p><code>d1 >> play("x-o-", hpf=linvar([0,2000],32), hpr=linvar([1,0.1],28))                                            </code></p>
                                <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>Filtro paso bajo</h3>
                                <h5>palabras clave: lpf, lpr = 1</h5>
                                <p>Del mismo modo que el filtro de paso alto sólo permite el paso de frecuencias dentro de una señal de audio por encima de un determinado límite, el filtro de paso bajo sólo permite el paso de frecuencias dentro de una señal de audio por debajo de un determinado límite. La resonancia de paso bajo, lpr, funciona de la misma manera que la resonancia de paso alto.</p>
                                
                               <p> <code>Ponga el filtro de paso bajo a 400 Hz.</code></p>
                               <p> <code>d1 >> play("x-o-", lpf=400)           </code></p>
                                    
                                <p><code># Cambiando la resonancia - ¿puedes oír la diferencia?</code></p>
                               <p> <code>d1 >> play("x-o-", lpf=400, lpr=0.2)                  </code></p>

                               <p> <code># Usa una linvar para variar ambos valores con el tiempo</code></p>
                              <p>  <code>d1 >> play("x-o-", lpf=linvar([500,5000],32), lpr=linvar([1,0.1],28))                                       </code></p>
                                <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>Bitcrush</h3>
                                <h5>palabras clave: crush, bits = 8</h5>
                                <p>El bitcrushing es un efecto de distorsión creado por la reducción de la frecuencia de muestreo de una señal de audio y del ancho de banda. Un valor de aplastamiento de 1 reducirá la velocidad de bits de la señal al valor de bits, que es 8 por defecto. Cada incremento de aplastamiento posterior reduce a la mitad la frecuencia de muestreo de la señal (a partir de 44,1 KHz). El efecto bitcrush requiere que los plugins SC3 estén instalados para funcionar.</p>
                                
                              <p>  <code># Aplica el efecto bit-crusher</code></p>
                              <p>  <code>d1 >> play("X O", crush=4)    </code></p>
                               
                              <p>  <code> # Reduce el número de bits para más distorsión</code></p>
                                <p><code>d1 >> play("X O", crush=4, bits=4)             </code></p>
                                
                                <p><code>#O reduzca la frecuencia de muestreo para un estilo diferente de distorsión!                                           </code></p>
                               <p> <code>d1 >> play("X O", crush=32, bits=8)             </code></p>
                                
                                <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>distorsión</h3>
                                <h5>palabra clave: dist</h5>
                                <p>Esto requiere la instalación de los plugins SC3. Este debe ser un valor entre 0 y 1 y distorsiona la señal de audio.</p>
                                
                              <p>  <code>#Añade distorsión tanto a los reproductores de muestra como a los de sintetizado                                       </code></p>
                                
                                
                               <p> <code>d1 >> play("x * ", dist=0.2)                   </code></p>
                               <p> <code>p1 >> dirt ([0,5], dist=0,3, dur=8) + (0,4)</code></p>
                                
                                <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>Distorsión de la forma de onda</h3>
                                <h5>palabras clave: shape</h5>
                                <p>Este es otro tipo de distorsión que afecta la forma de onda de la señal de audio. Este valor debe estar entre 0 y 1, pero también se aceptan valores mayores (¡cuidado con los auriculares!). Este efecto de distorsión no requiere ninguna instalación adicional.</p>
                                
                              <p>  <code>#Añade distorsión tanto a los reproductores de muestra como a los de sintetizador                                        </code></p>
                               <p> <code>d1 >> play("x * ", shape=0.5)                    </code></p>
                               <p> <code>p1 >> suciedad ([0,5], forma=0,5, dur=8) + (0,4) </code></p>
                                <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>Reverb</h3>
                                <h5>palabras clave:  room, mix = 0.1</h5>
                                <p>Utilice la palabra clave room para añadir reverberación a un sonido. Esto emula el efecto de tocar el sonido en una habitación y puede ser en una escala de seco (0% mezcla del sonido reverberado) a húmedo (100% mezcla del sonido reverberado). La palabra clave de la sala establece el tamaño de la sala para emular la reverberación, y la mezcla es la mezcla porcentual como una fracción (es decir, 0,1 es 10%).</p>
                                
                              <p>  <code> #emula el reproductor en un pequeño salon </code></p>
                              <p>  <code>p1 >> play("x o ", room=0.25)              </code></p>
                                
                              <p>  <code># Emular la reproducción de los sonidos en una habitación más grande                                           </code></p>
                              <p>  <code>p1 >> play("x o ", room=0.8)               </code></p>
                                
                             <p>   <code> # Haz que la señal sea más'húmeda         </code></p>
                                <p><code>p1 >> play("x o", room=0.8, mix=0.8)       </code></p>
                                
                                <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>eco</h3>
                                <h5>palabras clave: echo, decay = 1</h5>
                                <p>Este efecto a menudo se conoce con el nombre de "Comb Delay" pero aplicarlo a un solo sonido le dará el efecto de un eco en una habitación. Utilice la palabra clave eco para definir la duración (en tiempos) entre cada sonido repetido. El siguiente código reproduce una sola nota en repetición, pero oímos el eco de vuelta a nosotros después de 1 latido.</p>
                                
                                <code>p1 >> blip(dur=4, echo=1)                    </code>
                                
                                <p>NOTA: A veces puede que tenga que añadir reverberación utilizando el argumento de palabra clave de la sala para escuchar el efecto de eco. Esto se debe a que un sonido es detenido por el SuperCollider una vez que es detectado como silencioso. Si el eco se produce después de un período de silencio, tendrá que añadir reverberación para mantener el sonido "vivo" por así decirlo. He aquí un ejemplo:</p>
                                
                               <p> <code># No oímos ningún efecto de eco              </code></p>
                               <p> <code>d1 >> play("x-o-", dur=1, echo=0.75)         </code></p>
                                
                             <p>   <code># Añade reverberación y lo haremos             </code></p>
                              <p>  <code> d1 >> play("x-o-", dur=1, echo=0.75, room=0.5)</code></p>
                                
                                <p>Por defecto, probablemente sólo oirá un eco del sonido original. Para escuchar más ecos, aumente la duración de la caída:</p>
                                
                              <p> <code># Sólo oigo un eco        </code></p>
                               <p> <code>p1 >> blip(dur=4, echo=1) </code></p>
                                
                             <p>   <code># Ahora oímos varios              </code></p>
                             <p>   <code>p1 >> blip(dur=4, echo=1, decay=8)</code></p>
                                
                             <p>   <code># Podemos usar echo para hacer los bucles de batería más interesantes también                                          </code></p>
                              <p>  <code>d1 >> play("(x )( x)o ", room=0.1, echo=0.75/2, decay=4)</code></p>
                                
                                
                                <p>Tenga cuidado de no utilizar demasiado eco en demasiados reproductores, ya que utiliza una gran cantidad de CPU y puede provocar un fallo del SuperCollider.
                                </p>
                               <hr style= "border-color: #4e7c5c; width:90%"> 
                                <h3>Pan spin</h3>
                                <h5>palabras clave: spin</h5>
                                <p>Este efecto desplaza continuamente el sonido de izquierda a derecha, y viceversa, n número de veces, donde n es el valor dado. Esto depende del sustain de la nota (dado usando la palabra clave sus.</p>
                                
                              <p>  <code># Mueve la sartén de izquierda a derecha 4 veces a través de 4 tiempos                                 </code></p>
                                <p><code>p1 >> almohadillas(dur=4, spin=4) </code></p>
                                
                                <p># Mueve la cacerola de izquierda a derecha 4 veces a través de un latido</p>
                                
                               <p> <code>p1 >> pads(dur=4, sus=1, spin=4)  </code></p>
                             <hr style= "border-color: #4e7c5c; width:90%">   
                                <h3>cut</h3>
                                <h5> palabras clave: cut</h5>
                                <p>Para detener un sonido abruptamente (en lugar de usar sólo un sus más corto) puede usar la palabra clave "cortar". Esto es especialmente útil cuando se reproducen muestras utilizando la reproducción de SynthDef, ya que sus no tiene ningún efecto sobre el sonido en sí. La duración en la que se detiene el sonido es el valor de corte como proporción del valor sus, es decir, un corte de 0,5 detendrá el sonido a mitad de camino.</p>
                                
                                <p><code> # Detenga un sonido inmediatamente en lugar de su decadencia natural                              </code></p>
                            
                                <p><code>p1 >> pads(dur=4, corte=0.75)  </code></p>
                                
                               <p> <code># Acortar las muestras a una décima parte de su longitud normal                                          </code></p>
                                
                               <p> <code>d1 >> play("x-o-", cut=0.1)    </code></p>
                              <hr style= "border-color: #4e7c5c; width:90%">  
                                <h3>Filtro de formantos</h3>
                                <h5>palabras clave:  formant</h5>
                                <p> Esto usa la clase Formlet de SuperCollider para añadir un filtro de resonancia muy simple al sonido, no muy diferente al efecto "vocal" de TidalCycles. Los valores deben estar entre 1 y 7.</p>
                                
                                <p><code># Recorre los diferentes niveles podemos aplicar el filtro </code></p>
                             <p>   <code> p1 >> pluck(formant=P[:8])                                </code></p>
                            
                            
                            
                            
                            
                           
                              <hr style= "border-color: #4e7c5c; width:90%">  
                                <h3>Distorsión del Overdrive</h3>
                                <h5>palabras clave: drive</h5>
                                <p>Una distorsión creada al amplificar el sonido y luego recortarlo a una amplitud mucho más "normal". Los valores deben estar entre 0 y 1, pero se aceptan valores mayores.</p>
                                
                               <p> <code>#Añade distorsión de sobremarcha                            </code></p>
                              <p>  <code>p1 >> dirt(dur=1/2, accionamiento=1)                    </code></p>
                            

								</div>
								
								</div>
								
								</div>
					<div class="bb-item" id="item9">
						<div class="content">
							<div class="scroller">
								<h2>Metodos del Reproductor</h2>
                                
                                <p>Además de manipular a tus jugadores cambiando sus atributos, también puedes usar métodos para cambiar sus comportamientos. Algunos métodos simplemente aplican un "preset" a atributos específicos para ahorrar tiempo de escritura. Por ejemplo, el método spread equivale a ajustar la panorámica de un reproductor tanto a la izquierda como a la derecha y a compensar la afinación, utilizando el atributo pshift, en 0,125 semitonos en cada canal:</p>
                  
                                <p><code># Difundiendo un sonido a través de canales estéreo fuera de fase                                                      </code></p>
                                
                                <p><code>d1 >> play("x-o-", pan=(-1, 1), pshift=(0, 0.125))</code></p>
                                
                                <p><code># Esto se puede hacer usando el método "spread </code> </p>
                                
                                
                                  <p><code>d1 >> play("x-o-").spread() </code> </p>
                                
                                  <p><code># Las instrucciones se interpretan de izquierda a derecha, de modo que la dispersión anula el "pan=[-1, 0, 1]".          </code> </p>
                                 <p><code> d1 >> play("x-o-", pan=[-1, 0, 1]).spread()      </code> </p>
                                 <p><code># Usando "spread" *antes* el >> establecerá el paneo en[-1, 0, 1] pero pshift seguirá siendo (0, 0.125)                    </code> </p>
                                 <p><code>d1.spread() >> play("x-o-", pan=[-1, 0, 1])        </code> </p>
                                
                                <p>A continuación se muestra una lista de métodos que se pueden utilizar con el código de ejemplo adjunto. Esta lista está incompleta, así que por favor tengan paciencia conmigo mientras actualizo esta lista con más información.</p>
                                
                                 <hr style= "border-color: #4e7c5c; width:90%"> 
                                <h2>Métodos de clase</h2>
                                
                                <p><code>get_attributes()                       </code></p>
                                
                                <p>Devuelve una lista de los posibles atributos del reproductor que se pueden cambiar.</p>
                                
                                <p><code>print(Player.get_attributes())         </code></p>
                                
                                <p>('degree', 'oct', 'freq', 'dur', 'delay', 'blur', 'amplify', 'scale', 'bpm', 'sample', 'sus', 'fmod', 'pan', 'rate', 'amp', 'vib', 'vibdepth', 'slide', 'sus', 'slidedelay', 'slidefrom', 'bend', 'benddelay', 'coarse', 'striate', 'buf', 'rate', 'pshift', 'hpf', 'hpr', 'lpf', 'lpr', 'chop', 'echo', 'decay', 'spin', 'cut', 'room', 'mix', 'formant', 'shape') </p>
                                
                                <p><code>help()                                 </code></p>
                                
                                <p>Imprime la cadena de documentos de la clase Reproductor en la consola.</p>
                                
                                <p><code>Player.help()                          </code></p>
                                
                                <p><code>FoxDot genera música creando instancias de `Player` y dándoles instrucciones para seguir..."</code></p>
                                
                                
                                 <hr style= "border-color: #4e7c5c; width:90%"> 
                                <h2>"Métodos "mágicos</h2>
                                <h3>__init__(name=None)</h3>
                                
                                <p>Inicializa un nuevo objeto de reproductor que puede asignar instrucciones. Puede darle un nombre para que sea más fácil identificarlo al imprimir el contenido del reloj de programación, por ejemplo.</p>
                                
                                <p>Crea un nuevo reproductor (el nombre puede ser diferente al nombre de la variable)
                                foo = Jugador ("bar")
                                >>> foo >> pluck()
                                Imprimir el contenido del reloj
                                print(Clock.playing)
                               </p>
                                
                                <hr style= "border-color: #4e7c5c; width:90%">  
                              <h3>__repr__()</h3>
                                
                                <p>Devuelve la representación de la cadena del reproductor (llamada cuando se utiliza la impresión para mostrar información en la consola). Si se le ha dado un nombre, devolverá el nombre seguido del sintetizador que se está utilizando. Si no es así, sólo devolverá información sobre el synthdef.</p>
                                
                                <p><code># Con un nombre
                                            p1 = Reproductor ("p1")
                                            p1 >> almohadillas(> p1 >> almohadillas()
                                            imprimir(p1)
                                            "p1 - pads"
                                            # Sin un nombre
                                            p1 = Player()
                                            p1 >> almohadillas(> p1 >> almohadillas()
                                            imprimir(p1)
                                            "Un'puntear' Objeto de reproductor</code></p>
                                 <hr style= "border-color: #4e7c5c; width:90%"> 
                               <h3>addd__(valor)</h3>
                                
                                <p>Esto agrega valor al grado del Jugador. Si está utilizando el play synthdef, el valor se añade al atributo de muestreo en su lugar.</p>
                                
                               <p><code># Las dos líneas son equivalentes
                                p1 >>pads (P[0, 1, 2, 3] + (0, 4))
                                p1 >> pads (P[0, 1, 2, 3]) + (0, 4)

                                #Puede ser un patrón, PGroup, var, o un solo número
                                p1 >>pads (P[0, 1, 2, 3]) +[0, 0, 4]
                                p1 >> pads (P[0, 1, 2, 3]) + var([0, -2], 8)</code></p> 
                                
                                
                                <p>El uso de 'play' alterará los valores de la muestra de manera que estas líneas sean equivalentes</p>
                                
                                <p><code>p2 >> play("x-o-", sample=P[2, 3] +[0, 0, 1])
                                         p2 >> play("x-o-", sample=[2, 3]) +[0, 0, 1]</code></p>
                                
                                <p>¿Qué es lo que quieres?</p>
                                
                                <p>El __getattr__ se llama cuando se recupera un atributo, como la           amplitud, de un reproductor
                                    usando p1.amp. Esto devuelve un objeto PlayerKey, que actúa de forma similar a un TimeVar.</p>
                                
                                <p><code>__setattr__(attr, value)
                                         __invert__()</code></p>
                                
                                
                                <p>Es la abreviatura del método de reinicio.</p>
                                
                                <p><code>#Restablece todos los atributos y luego actualiza el reproductor con el nuevo 'rate'.</code></p>
                                
                                <p><code>p1.reset() >> play("x-o-", rate=2)</code></p>
                                
                                <p> Equivalente a la línea de arriba</p>
                                
                                <p><code>p1 >> play("x-o-", rate=2)</code></p>
                                
                                <p>Métodos de instancia</p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>stop()</h3>
                                
                                <p>Elimina el Reproductor del reloj de programación para que ya no pueda escucharlo.</p>
                                
                                
                                <p><code># Si un jugador está corriendo, use .stop() para detenerlo!</code></p>
                                
                                <p><code>p1.stop()</code></p>
                                
                                <p>También puede añadir el método al final de la línea</p>
                                <p><code>p1 >> pluck().stop()</code></p>
                                <hr style= "border-color: #4e7c5c; width:90%">  
                                <h3>reset()</h3>
                                <p>Restablece todos los valores de atributo a sus valores originales. Esto es cero para todos los valores excepto oct, rate y amp, que son 5, 1 y 1 respectivamente.</p>
                                
                                <p><code># Empieza un reproductor</code></p>
                                
                                <p><code>p1 >> play("x-o-", dur=1, rate=2, hpf=4000)</code></p>
                                
                                <p><code>Restablecer los atributos a los valores predeterminados</code></p>
                                <p><code>p1.reset()</code></p>
                                
                                <p><code>Útil cuando no se desea ajustar manualmente los valores a 0, por ejemplo</code></p>
                                
                                <p><code>p2 >> pluck([0, 2, 4, 7], dur=1/4, hpf=500, pan=[-1,1])</code></p>
                                
                                <p><code># Establece el dur a 1, hpf a 0 y pan a 0</code></p>
                                <p><code>p2.reset() >> pluck([0, 2, 4, 7])</code></p>
                                
                                 <hr style= "border-color: #4e7c5c; width:90%"> 
                                <h3>solo(switch=1)</h3>
                                
                                <p>Silencia a todos los demás Jugadores activos de tal manera que este Jugador es el único que se escucha. Para anular el silenciamiento de un jugador individual, basta con reevaluar una línea de código. Para desactivar el silenciamiento de todos los reproductores, llame a este método con el conmutador puesto en 0 o Falso.</p>
                                
                                <p><code># Empieza unos cuantos jugadores</code></p>
                                <p><code>d1 >> play("x-o-")</code>
                                     <code>   p1 >> pluck([0,2], dur=PDur(3,8))</code></p>
                                <p><code># Solo p1</code></p>
                                <p><code>p1.solo()</code></p>
                                
                                <p><code># Re-añade a otros jugadores</code></p>
                                <p><code>p1.solo(0)</code></p>
                                 <hr style= "border-color: #4e7c5c; width:90%"> 
                                <h3>only()</h3>
                                
                                <p>Detiene a todos los demás Jugadores activos. A diferencia de solo, este efecto no puede deshacerse usando sólo(0) ya que la parada es permanente. Necesita reintroducir manualmente los reproductores.</p>
                                
                                <p><code># Empieza unos cuantos jugadores</code></p>
                                <p><code>d1 >> play("x-o-")</code></p>
                                <p><code>p1 >> pluck([0,2], dur=PDur(3,8))</code></p>
                                <p><code> p2 >> pads ([0,3], </code></p>
                                 <hr style= "border-color: #4e7c5c; width:90%"> 
                                <h3>now(attr="degree")</h3>
                                <p>Devuelve el valor actual (es decir, el último valor reproducido) para un atributo dado. Por defecto, éste es el grado (tono o carácter de ejemplo), pero puede especificar el nombre del atributo como una cadena.</p>
                                
                                <p><code>#Iniciar un reproductor</code></p>
                                <p><code> p1 >> pluck([0, 2, 4], dur=[1, 2, 5])</code></p>
                                
                                <p><code>Imprimir el tono y la duración</code></p>
                                <p><code>print(p1.now(), p1.now("dur"))</code></p>
                                <p><code>0, 1</code></p>
                                <p><code>print(p1.now(), p1.now("dur"))</code></p>
                                <p><code>2, 2</code></p>
                                <p><code>print(p1.now(), p1.now("dur"))</code></p>
                                <p><code>4, 5</code></p>
                                
                                 <hr style= "border-color: #4e7c5c; width:90%"> 
                                <h3>every(n, method_name, *args, **kwargs)</h3>
                                
                                <p>Utilícelo para llamar a un método cada n número de latidos. Especifique el nombre del método como una cadena y, a continuación, los argumentos y los argumentos de palabra clave para proporcionar el método. Consulte Manipulación algorítmica para obtener información más detallada sobre cada.</p>
                                
                                <p><code># Empieza un reproductor</code></p>
                                <p><code>p1 >> arrancar ([0,1,2,3,4,5,6,7,8])</code></p>
                                <p><code># Invierte el orden cada 8 latidos</code></p>
                                <p><code>p1.every(8, "reverse")</code></p>
                                <p><code># Las llamadas a múltiples métodos pueden ser encadenadas entre sí</code></p>
                                <p><code></code>p1 >> pluck([0,2,4,7]).every(4, "reverse").every(8, "rotate")</p>
                                 <hr style= "border-color: #4e7c5c; width:90%"> 
                                <h3>after(n, method_name, *args, **kwargs)</h3>
                                
                                <p>Similar a todos, pero sólo llama al método una vez después de n número de latidos. Esto puede ser útil, por ejemplo, para reproducir en bucle una secuencia durante un tiempo determinado:</p>
                                <p><code># Stop a drum loop after 8 beats</code></p>
                                <p><code>d1 >> play("x-o-").after(8, "stop")</code></p>
                                
                                 <hr style= "border-color: #4e7c5c; width:90%"> 
                                <h3>stutter(n, *args, **kwargs)</h3>
                                
                                <p>Repita el último evento musical n veces. Puede especificar argumentos de palabras clave, ya que normalmente actualizaría un reproductor para controlar el tartamudeo. La palabra clave dur cambia la duración durante la cual se extienden los eventos tartamudeados (por defecto es el valor de duración actual del Reproductor).</p>
                                
                                
                                <p><code> # Empieza un jugador</code></p>
                                 <p><code>d1 >> play("x-o-")</code></p>
                                 <p><code># Tartamudea una vez</code></p>
                                 <p><code>d1.stutter()</code></p>
                                 <p><code> # Tartamudea 4 veces (3 eventos extra)</code></p>
                                 <p><code>d1.stutter(4)</code></p>
                                <p><code>#Tartamudeo 8 veces más de 2 latidos y paneo alternativo</code></p>
                                <p><code>d1.stutter(8, dur=2, pan=[-1,1])</code></p>
                                
                                <p><code># Muy útil cuando se combina con "cada"</code></p>
                                <p><code>d1.every(8, "tartamudeo", 4, dur=3)</code></p>
                                
                                 <hr style= "border-color: #4e7c5c; width:90%"> 
                                <h3>jump(ahead=1, **kwargs)</h3>
                                <p>Reproduce el evento que está un número de pasos por delante de la posición actual del reproductor, tal y como se especifica en el argumento ahead. Esto se utiliza mejor en conjunción con cada método:</p>
                                
                                <p><code># Toca el tambor media hora después de 6.5 golpes</code></p>
                                 <hr style= "border-color: #4e7c5c; width:90%"> 
                                <h3>spread(pshift=0.125)</h3>
                                <p>Ajusta la panoramización tanto a la izquierda como a la derecha y compensa la afinación en 0,125 semitonos de forma predeterminada para obtener un sonido estéreo más denso.</p>
                                
                                <p><code># Sin esparcirse</code></p>
                                <p><code>p1 >> pluck([0, 4], oct=4, dur=PDur(3,8), sus=2)</code></p>
                                <p><code># Con un poco de esparcimiento</code></p>
                                <p><code>p1 >> pluck([0, 4], oct=4, dur=PDur(3,8), sus=2).spread()</code></p>
                                 <hr style= "border-color: #4e7c5c; width:90%"> 
                                <h3>slider(start=0, switch=1)</h3>
                                
                                <p>Crea un efecto de diapositivas alternado con el reproductor. Fijar inicio a 1 para cambiar el orden de las diapositivas de arriba hacia abajo. Utilice switch=0 para desactivar el efecto o el método de reinicio.</p>
                                
                                
                                <p><code>#Reproductor básico </code></p>
                                <p><code>p1 >> saw([7, 0, 3, 1, 7, 4, 5, 2], dur=1/4, oct=4)</code></p>
                                <p><code># Con deslizador añadido</code></p>
                                <p><code>p1 >> saw([7, 0, 3, 1, 7, 4, 5, 2], dur=1/4, oct=4).slider()</code></p>
                                 <hr style= "border-color: #4e7c5c; width:90%"> 
                                <h3>penta(switch=1)</h3>
                                <p>Establece la escala en el modo pentatónico de la escala por defecto. Use switch=0 para volver a la escala por defecto.</p>
                                
                                <p><code>#Escala por defecto</code></p>
                                <p><code>p1 >> pluck([0, 1, 2, 3, 4, 5, 6, 7])</code></p>
                                
                                <p><code>#Pentatónica</code></p>
                                <p><code>p1 >> pluck([0, 1, 2, 3, 4, 5, 6, 7]).penta()</code></p>
                                
                                 <hr style= "border-color: #4e7c5c; width:90%"> 
                                <h3> degrade(amount=0.5)</h3>
                                <p>Establece la amplitud a elegir entre 1 y 0 de forma aleatoria. El argumento de la cantidad es la probabilidad de que la amplitud sea 0 como una fracción, es decir, una degradación de 0,5 (por defecto) significa que cada evento tiene un 50% de probabilidad de ser un 0 y a 0,1 tiene un 10% de probabilidad de ser un 0.</p>
                                
                                <p><code># Empieza un jugador</code></p>
                                <p><code>p1 >> pluck()</code></p>
                                <p><code># Empieza a disminuir el número de eventos</code></p>
                                <p><code>p1.degrade()</code></p>
                                <p><code># Puede ser llamado repetidamente para degradarse en un 25% cada 8 latidos</code></p>
                                <p><code>p1.every(8, "degradar", 0.25)</code></p>
                               <hr style= "border-color: #4e7c5c; width:90%"> 
                                <h3>offbeat(n=1)</h3>
                                <p>Establece el dur a n y el retardo a n / 2 para que cada nota se toque en el offbeat.</p>
                                
                                <p><code># Usa la percusión para escuchar la diferencia</code></p>
                                <p><code>d1 >> play("x-o-")</code></p>
                                <p><code>p1 >> pluck()</code></p>
                                <p><code># Establece la duración a 1 y fuera de lo común</code></p>
                                <p><code>p1.offbeat()</code></p>
                                <p><code># Establece la duración a 2 y desactívalo cada 2 latidos</code></p>
                                <p><code>p1.offbeat(2)</code></p>
                                
                                 <hr style= "border-color: #4e7c5c; width:90%"> 
                                <h3>reverse()</h3>
                                
                                <p>Invierte el orden de todos los atributos en el momento actual. Este método no invierte las listas de valores, sino que invierte el orden en que se utilizan.</p>
                                
                                <p><code># Reproduce una octava</code></p>
                                <p><code>p1 >> pluck([0, 1, 2, 3, 4, 5, 6, 7])</code></p>
                                <p><code># Llama en reversa y las notas empiezan a descender</code></p>
                                <p><code>p1.reverse()</code></p>
                                
                                <p><code># Llamada usando "cada" para movimiento orgánico arriba y abajo</code></p>
                                <p><code>p1.every([6,3], "inversa")</code></p>
                                <hr style= "border-color: #4e7c5c; width:90%">  
                                <h3>rotate(n=1)</h3>
                                <p>Mueve todos los elementos de la cartografía de afinación/muestreo en n pasos de tal forma que la nueva lista de datos se inicia de forma equivalente, pero comienza en el enésimo elemento de la lista original.</p>
                                
                                <p><code># Empieza un reproductor</code></p>
                                <p><code>p1 >>pluck ([0,1,2,3])</code></p>
                                <p><code>Girando[0,1,2,3] lo cambia a[1,2,3,0]</code></p>
                                <p><code>p1.rotate()</code></p>
                                
                                 <hr style= "border-color: #4e7c5c; width:90%"> 
                                <h3> shuffle()</h3>
                                <p>Aleatoriza el orden del atributo del carácter de afinación / ejemplo.</p>
                                
                                <p><code># Empieza un jugador  </code>
                                 <p>   <code>     p1 >> arrancar ([0,1,2,3])</code></p>

                                      <p>   <code> # Cambia el orden una vez</code> </p>
                                <p>    <code>   p1.shuffle()</code></p>

                                          <p> <code># Cambia el orden cada 8 latidos</code> </p>
                                   <p>    <code>   p1.every(8, "barajar")</code></p>
                                 <hr style= "border-color: #4e7c5c; width:90%"> 
                                <h3>follow(reproductor)</h3>
                                <p>Sigue el terreno de juego del jugador. Es equivalente a ajustar la afinación de un reproductor, por ejemplo, p1, a la afinación de otro usando p2.pitch.</p>
                                
                                <p><code> # Empieza un reproductor</code></p>
                                <p><code>p1 >> pluck([0, 1, 2, 3], dur=2)</code></p>
                                <p><code># Sigue el tono en p2</code></p>
                                <p><code>p2 >> blip().follow(p1)</code></p>
                                <p><code># Añade valores para cambiar el tono</code></p>
                                <p><code>p2 >> blip().follow(p1) +[0, 2]</code></p>
                                
                                
                                <hr style= "border-color: #4e7c5c; width:90%">  
                                <h3>accompany(player)</h3>
                                
                                <p>De forma similar a la siguiente, este método obliga al jugador a tocar notas derivadas de la afinación de otro jugador. El campo será el vecino más cercano al último campo utilizado, es decir, el nuevo campo del reproductor fuente más 0, 2 ó 4.</p>
                                
                                <p><code># Empieza un reproductor</code></p>
                                <p><code>p1 >> pluck([0, 1, 2, 3], dur=2)</code></p>
                                <p><code># player en los campos de acompañamiento</code></p>
                                <p><code>p2 >> blip().accompany(p1)</code></p>
                                <p><code># Añade valores para cambiar el tono</code></p>
                                <p><code>p2 >> blip().accompany(p1) +[0, 2]</code></p>
                                 <hr style= "border-color: #4e7c5c; width:90%"> 
                                attrmap(clave1, clave2, mapeo)

                                Indocumentado
                               
                                 <hr style= "border-color: #4e7c5c; width:90%"> 
                                smap(mapeo)

                                Indocumentado
                                 <hr style= "border-color: #4e7c5c; width:90%"> 
                                map(player, mapping, attr="degree")

                                Indocumentado
                                 <hr style= "border-color: #4e7c5c; width:90%"> 
                                bang(**kwargs)

                                Indocumentado
                                </div>
								
								</div>
								
								</div>
                    <div class="bb-item" id="item10">
						<div class="content">
							<div class="scroller">
								<h2> Manipulación algoritmica</h2>
				<p>Una de las cosas buenas de la codificación en vivo es que puede programar eventos para que ocurran, o se repitan, en el futuro. Esto le permite continuar codificando mientras se llaman funciones repetidas y añadir variedad a su música. Esta sección es un análisis detallado de cómo se implementa cada método del Reproductor y cómo puede combinar varias instancias del mismo para crear música compleja a partir de patrones simples.
             </p>
                                 <hr style= "border-color: #4e7c5c; width:90%"> 
                                <h3>Fundamentos</h3>
                                <p>Primero veamos un ejemplo simple que invierte una secuencia cada 8 latidos:</p>
                                <p><code>p1 >> pluck([0, 1, 2, 3, 4, 5, 6, 7]).every(8, "reverse")</code></p>
                                <p>El primer argumento es el número de pulsaciones entre cada llamada de un método y el segundo es el nombre del método en sí como una cadena. La razón para usar el nombre de cadena del método en lugar de una función es que Python puede comprobar si el método es válido usando la función getattr y generar un error si no lo es. Ejecutando el código <code>print(getattr(p1, "reverse"))</code> le dará algo similar al método bound Player.reverse of p1 - pluck. Lo que entonces sucede, en esencia, es que el reloj de programación ejecuta <code>getattr(p1, "reverse").__call__()</code> cada 8 tiempos.</p>
                                
                                <p>Puede utilizar una lista de duraciones para programar llamadas a métodos a intervalos irregulares:</p>
                                
                                <p><code>p1 >> pluck([0, 1, 2, 3, 4, 5, 6, 7]).every([6, 2], "reverse")</code></p>
                                
                                <p>El código de arriba llamará al método inverso después de 6 latidos, luego 2 latidos después de eso, luego otra vez 6 latidos después de esa llamada, repitiendo esto hasta que se detenga. También puede utilizar un objeto Pattern o PatternGenerator como PRand para llamar métodos a veces no predeterminados:</p>
                                <p><code>p1 >> pluck([0, 1, 2, 3, 4, 5, 6, 7]).every(PRand([2, 4, 8]), "reverse")</code></p>
                                <p>Si intenta especificar varias llamadas del mismo método, verá que sólo se programa la última llamada actualizada. Si desea utilizar más de una llamada repetida al mismo método, puede utilizar la palabra clave de identificación y darle un nombre o número para diferenciarla:</p>
                                <p><code># Llama "reversa" cada 8 latidos *y* cada 5 latidos</code></p>
                                <p><code>d1 >> pluck([0, 1, 2, 3, 4, 5, 6, 7]).every(8, "reverse").every(5, "reverse", ident=1)</code></p>
                                
                                
                                <p>Los métodos de los jugadores que pueden ser usados con cada uno efectivamente son reversa, rotación, barajar, saltar y tartamudear.
                                La palabra clave del ciclo</p>
                                <p><code>La palabra clave del ciclo</code></p>
                                
                                <p>A veces puede ser útil programar un método para el mismo punto en un ciclo de N-tiempos, por ejemplo, tartamudear el sonido en el 6º tiempo de cada ciclo de 8 tiempos. Puede hacerlo simplemente especificando la longitud del ciclo como argumento de palabra clave:</p>
                                
                                <p><code>d1 >> play("x-o-").every(6, "stutter", cycle=8)</code></p>
                                <p>En lugar de llamar tartamudeo a cada 6 latidos, se llama cada 8 latidos (el tamaño del ciclo), pero compensado por 6 latidos.
                                El método del tartamudeo en profundidad</p>
                                
                                <p>Uno de los métodos más útiles que se puede llamar usando cada uno es el método del tartamudeo. Reproduce el último evento enviado a SuperCollider varias veces a lo largo de una duración especificada. También puede especificar atributos/efectos para adjuntar a los eventos como pan o shape usando argumentos de palabras clave.</p>
                                
                                <p>Puede especificar el número de veces que un evento tartamudea simplemente proporcionando un número entero a cada llamada siguiendo el nombre del método como una cadena. El valor por defecto es 2, lo que significa que escuchará 1 evento adicional - 2 menos el evento que ya se está reproduciendo. Usando un valor de 4 se reproducirán 3 eventos extra (ya tienes la idea). Por defecto, los eventos serán tartamudeados a lo largo de la duración del evento que está tartamudeando, pero también puede tartamudear los eventos a lo largo de un período de tiempo determinado mediante el suministro de una palabra clave dur:</p>
                                
                                <p><code># Reproducir el evento 4 veces cada 6 latidos a través de 1/2 latido</code></p>
                                <p><code>d1 >> play("x-o-", dur=1/2).every(6, "stutter", 4)</code></p>
                                <p><code># Juega el evento 4 veces cada 6 latidos a través de 3 latidos</code></p>
                                <p><code>d1 >> play("x-o-", dur=1/2).every(6, "stutter", 4, dur=3)</code></p>
                                <p><code>También puede especificar el número de eventos a tartamudear usando la palabra clave 'n</code></p>
                                <p><code>d1 >> play("x-o-", dur=1/2).every(6, "stutter", dur=3, n=4)</code></p>
                                
                                <p>Así como usted proporciona argumentos de palabras clave para controlar el sonido de sus sintetizadores, puede hacer lo mismo con el tartamudeo para controlar el sonido que se está reproduciendo. Estos pueden ser una lista o patrón de valores que se dan a cada evento tartamudeado a su vez, es decir, no jugado todos a la vez:</p>
                                
                                
                                <p><code># Tartamudea 8 veces con el aumento de la velocidad de reproducción</code></p>
                                <p><code>d1 >> play("x-o-").every(4, "stutter", 8, rate=[1,2,3,4,5,6,7,8])</code></p>
                                 <p><code># Tartamudeo 4 veces con paneo alternado y mayor velocidad</code></p>
                                <p><code>d1 >> play("x-o-").every(4, "stutter", 4, dur=3, pan=[-1, 1], rate=2)</code></p>
                                 <p><code>#Todavía puedes usar tuplas / PGroups para añadir efectos simultáneos</code></p>
                                <p><code>d1 >> play("x-o-").every(4, "stutter", 4, dur=1, pan=(-1,1), rate=(4, 1/2))</code></p>
                                <p>Tenga en cuenta que cuando se utiliza una lista de valores, sólo se utilizarán los primeros n valores (donde n es el número de veces que se tartamudea).</p>
                                 <hr style= "border-color: #4e7c5c; width:90%"> 
                                <h3>Uso de métodos de patrones</h3>
                                
                                <p>Además de revertir, rotar, barajar, saltar y tartamudear, también puede programar cualquier método que pertenezca a la clase Patrón para que se llame en cualquier atributo de un reproductor. El comportamiento es ligeramente diferente a cuando se programan los métodos de los jugadores en el sentido de que en lugar de ser llamado cada n beats, es llamado y luego desllamado so-to-speak. Probablemente es mejor demostrarlo con un ejemplo:</p>
                                
                                <p><code>Llama al método "trim" en el atributo de grado</code></p>
                                <p><code>d1 >> play("x-o-").every(4, "trim", 3)</code></p>
                                
                                <p>El patrón "x-o-" se recorta a sólo "x-o" después de 4 tiempos y luego vuelve a "x-o-" de nuevo después de los siguientes 4 tiempos. Por defecto, el método se llama atributo grado (que es pitch para la mayoría de los sintetizadores y la cadena de caracteres para el sintetizador de reproducción) - puede especificar un atributo diferente anteponiendo al nombre del método el nombre del atributo y luego un ":</p>
                                
                                
                                <p><code># Trim the octave pattern to 3 every 4 beats</code></p>
                                <p><code>p1 >> pluck([0,1,2,3], oct=[4,5,6,7]).every(4, "oct.trim", 3)</code></p>
                                
                                <p>Los argumentos que se proporcionarían al método del patrón se dan siguiendo el nombre del método. Por ejemplo, el método de patrón offadd, que superpone un patrón consigo mismo pero con un valor añadido y retrasado por una duración, toma 2 argumentos; el valor a añadir y el tiempo de retardo (por defecto es 0,5). Aquí hay algunos ejemplos de cómo usarlo con cada una de las aplicaciones:</p>
                                
                                <p><code># Toca una nota 2 pasos más alto retrasado 1/2 latido</code></p>
                                <p><code>p1 >> pasha([0, 4], dur=[3/4, 3/4, 1/2]).every(3, "offadd", </code></p>
                                <p><code># Toca una nota 4 pasos más alto retrasado 3/4 de un ritmo</code></p>
                                <p><code>p1 >> pasha ([0,1,3,4], dur=1/2).every(5, "offadd", 4, 3/4)</code></p>
                                
                                <p>Puede utilizar cualquier método de la clase Patrón, que puede ver ejecutando help(Pattern) o mirando las descripciones en profundidad.</p>
                                
								
								</div>
								
								</div>
								
								</div>
					<div class="bb-item" id="item11">
						<div class="content">
							<div class="scroller">
								<h2> Escalas y afinación</h2>

                                <p>FoxDot se inspira mucho en la teoría tradicional de la música occidental, incluyendo el uso de escalas musicales. Una escala es esencialmente un subconjunto de las notas musicales (tonos) entre una nota, por ejemplo C, y la misma una octava más alta. La nota inicial es la clave de la escala. Así que comenzando en Do, estas notas son: </p>
                                
                                <p><code>C, C#, D, D#, E, F, F#, G, G#, A, A#, B</code></p>
                                
                                <p>
                                    Este conjunto de todas las notas se llama la escala cromática. Si esto fuera una lista de Python llamada cromática, entonces cromática[0] devolvería C, cromática[1] devolvería C#, cromática[2] devolvería D, y así hasta cromática[11], que devolvería B. Debido a que cada escala musical es un subconjunto de estos tonos, podemos pensar en cada escala como una lista de índices para acceder a los tonos en la escala cromática. Veamos la escala mayor como ejemplo:</p>
								
                                
                                <p>La escala de Do Mayor se compone de C, D, E, F, G, A y B:</p>
                                
                                <p><code>cromático =[C, C#, D, D#, E, F, F#, G, G#, A, A#, B]</code></p>
                                <p><code>C = cromático[0]</code></p>
                                <p><code>D = cromático[2]</code></p>
                                <p><code>E = cromático[4]</code></p>
                                <p><code>F = cromático[5]</code></p>
                                <p><code>G = cromático[7]</code></p>
                                <p><code>A = cromático[9]</code></p>
                                <p><code>B = cromático[11]</code></p>
                                
                                <p>Una forma de crear la escala mayor usando un bucle podría ser:</p>
                                <p><code>pasos =[0, 2, 4, 5, 7, 9, 11]</code></p>
                                <p><code>Escala = []</code></p>
                                <p><code>para el paso en la escala:</code></p>
                                <p> <code>-scale.append(cromático[paso])</code></p>
                                <p><code># escala ==[C, D, E, F, G, A, B]</code></p>
                                
                                <p>Nuestra lista de pasos contiene los índices necesarios para crear la escala mayor. Así que cuando usamos el siguiente código para tocar todas las notas de la escala, estamos suministrando otra lista de índices, que se está usando para acceder a la lista de escalas:
                                </p>
                                
    
                                <p><code># Toca cada nota en la escala</code></p>
                                <p><code>p1 >> pluck([0, 1, 2, 3, 4, 5, 6, 7])</code></p>
                                <p><code># Esencialmente estamos jugando:</code></p>
                                <p><code>p1 >> pluck([scale[0], scale[1], scale[2], ..., scale[7])</code></p>
                                <p><code># Que es equivalente a:</code></p>
                                <p><code>p1 >> pluck([cromático[0], cromático[2], cromático[4], escala[5], ...., cromático[11])</code></p>
                                
                                <p>A veces puede que quieras usar una nota que no está en la escala, tan "aguda" como Do# en la escala de Do Mayor, que se llama "accidental" aunque sea a propósito. Puedes usar números en coma flotante y FoxDot se aproximará a la nota a la que intentas acceder. Por ejemplo, para acceder a C# en la escala de Do mayor, usaría la escala[0.5] porque C# está entre C y D, que son la escala[0] y la escala[1] respectivamente.</p>
                                
                                <h3>Lista de escalas</h3>
                                <p>Para ver una lista de las escalas disponibles simplemente ejecute el comando <code>print(Scale.names()).</code> Esto devolverá una lista de todas las escalas como cadenas así:</p>
                                
                                <p><code> print(Scale.names())</code></p>
                                <p>['aeolian', 'chinese', 'chromatic', 'custom', 'default', 'diminished', 'dorian', 'dorian2', 'egyptian', 'freq', 'harmonicMajor', 'harmonicMinor', 'indian', 'justMajor', 'justMinor', 'locrian', 'locrianMajor', 'lydian', 'lydianMinor', 'major', 'majorPentatonic', 'melodicMajor', 'melodicMinor', 'minor', 'minorPentatonic', 'mixolydian', 'phrygian', 'prometheus', 'romanianMinor', 'yu', 'zhi']</p>
                                
                                <p>Se puede acceder a cada objeto de la escala escribiendo Escala seguido de un ":</p>
                                
                                <p><code># Ver los semitonos de la escala mayor</code></p>
                                <p><code> print(Escale.major)</code></p>
                                <p><code># Accede a lo largo de la escala mayor</code></p>
                                <p><code>print(len(Scale.major))</code></p>
                                
                                <h3>Ajuste de la escala</h3>
                                
                                <p>De forma predeterminada, cada reproductor utiliza una escala predeterminada accesible de forma global llamada Scale.default. Esto se puede cambiar de varias maneras:</p>    
                                
                                <p><code># Simplemente asignando el objeto de escala a Scale.default</code></p>
                                <p><code>Scale.default  = Scale.minor</code></p>
                                <p><code># Puedes usar el nombre de la cadena</code></p>
                                <p><code>Scale.default = "minor"</code></p>
                                <p><code>También puede utilizar el método "set", que permite más opciones</code></p>
                                <p><code>Scale.default.set("minor")</code></p>
                                
                                <p>Los jugadores individuales pueden utilizar escalas independientes simplemente suministrando un objeto de escala a la palabra clave de la escala como lo haría con cualquier otro atributo de reproductor:</p>
                                
                                <p><code># Establece la escala a mayor</code></p>
                                <p><code>Scale.default = Scale.major</code></p>
                                <p><code># Forzar a un reproductor a usar la escala menor</code></p>
                                <p><code>p1 >> pluck([0,1,2,3], scale=Scale.minor)</code></p>
                                
                                <h3>Afinación y personalización</h3>
                                <p>La afinación musical es esencialmente la relación entre las frecuencias de las notas en una escala. La afinación más comúnmente utilizada en la música popular occidental es la afinación temperada igual de 12 pasos, que se encuentra en instrumentos como un piano. Otro sistema de afinación muy popular es el de "sólo entonación", que se analizará a continuación. Puede leer más sobre estos sistemas de ajuste haciendo clic en los enlaces del texto de arriba.</p>

                                <p>Del mismo modo que podemos ver los objetos de escala, también podemos ver los objetos de afinación:</p>
                                <p><code># Igual de temperamental</code></p>
                                <p><code>print(Tuning.ET12)</code></p>
                                <p><code># Sólo entonación</code></p>
                                <p><code>print(Tuning.just)</code></p>
                                
                                <p>Usando Scale.default.set también podemos establecer la afinación para la escala por defecto, así que ajustemos la afinación a sólo entonación mientras tocamos un acorde mayor y escuchemos el ligero cambio de color:</p>
         

                                <p><code> # Toca un acorde en repetición</code></p>
                                <p><code>p1 >> pluck((0, 2, 4))</code></p>
                                <p><code># Establece la sintonía en sólo</code></p>
                                <p><code>Escala.default.set("major", tuning=Tuning.just)</code></p>
                                <p><code># Vuelve a tener el mismo temperamento</code></p>
                                <p><code>Escala.default.set("major", tuning=Tuning.ET12)</code></p>
                                <p>Usted no tiene que usar escalas o afinación existentes - ¡puede incluso usar las suyas propias! Simplemente usando una lista o patrón de números en lugar de la escala y sintonizando nombres.</p>
                                <p><code>Scale.default.set([0, 2, 3, 5, 6, 9, 10], tuning=[0.1, 0.9, 2.1, 2.9, 4.1, 4.9, 6.1, 6.9, 8.1, 8.9, 10.1, 10.9])</code></p>
                                
                                
                                
								</div>
								
								</div>
								
								</div>
                    <div class="bb-item" id="item12">
						<div class="content">
							<div class="scroller">
								<h2>Configuración MIDI</h2>
                                <p>Esta sección trata sobre el uso de los reproductores FoxDot para secuenciar eventos musicales utilizando un dispositivo MIDI externo. Esto requiere las versiones más actualizadas de FoxDot y el SuperCollider "FoxDot Quark". Puedes encontrar más información sobre cómo mantenerte al día aquí.</p>
                                
                                <h3>Envío de mensajes a un dispositivo MIDI </h3>
                                
                                <p>Lo primero que hay que hacer es conectar el portátil al dispositivo MIDI y asegurarse de que se instalan los controladores correctos, lo que suele ocurrir automáticamente, aunque no siempre. A continuación, asegúrese de que SuperCollider pueda "ver" el dispositivo. Para ello, abra el SuperCollider y ejecute esta línea de código:</p>
                                
                                <p><code>FoxDot.midi</code></p>
                                
                                <p>A continuación, debería ver un mensaje en la "ventana de mensajes" en este sentido:</p>
                                
                                <p><code>MIDI: device 0 2 -1202759152  (Microsoft GS Wavetable Synth)</code></p>
                                <p><code>MIDI: device 1 3 -1202759144  (USB2.0-MIDI)</code></p>
                                <p><code>MIDI Sources:</code></p>
                                <p><code>MIDIEndPoint("USB2.0-MIDI", "USB2.0-MIDI")</code></p>
                                <p><code>MIDI Destinations:</code></p>
                                <p><code>MIDIEndPoint("Microsoft GS Wavetable Synth", "Microsoft GS Wavetable Synth")</code></p>
                                <p><code>MIDIEndPoint("USB2.0-MIDI", "USB2.0-MIDI")</code></p>
                                <p><code>-> MIDIClient</code></p>
                                
                                <p>En caso contrario, consulte la documentación de SuperCollider sobre MIDIClient. Esta es una lista de los dispositivos MIDI a los que SuperCollider (y FoxDot) pueden enviar mensajes. El primer dispositivo es el sintetizador MIDI interno de Microsoft para Windows y el segundo es un dispositivo externo conectado por USB (estos pueden tener diferentes nombres dependiendo del dispositivo y la conexión). Por defecto, FoxDot enviará mensajes al primer destino MIDI ("Microsoft GS Wavetable Synth" en este ejemplo) pero puedes seleccionar un dispositivo diferente ejecutando el mismo código pero con el índice del dispositivo preferido entre paréntesis. Así que para seleccionar el dispositivo "USB2.0-MIDI" me ejecutaría:</p>
                                
                                
                                <p><code>FoxDot.midi(1)</code></p>
                                
                                <p>Ahora puedes enviar mensajes a tu dispositivo MIDI desde FoxDot! Para hacer esto, necesitas usar el sintetizador MidiOut. Funciona igual que un sintetizador normal pero envía mensajes de tono y amplitud a un dispositivo MIDI, por ejemplo</p>
                                <p><code>p1 >> MidiOut([0,1,2,3,4,5], dur=PDur(3,8), amp=[1,1/2,1/2]).every(6, "stutter", 4, dur=3, oct=6)</code></p>
                                
                                
                                <p>Puede especificar el canal MIDI como lo haría con cualquier otro atributo, por ejemplo, usando el canal = 1, que por defecto es 0.</p>
                                
                                
                                <p><code>p1 >> MidiOut([0,1,2,3], canal = 1)</code></p>
                                <p>Nota: Tenga cuidado al repetir la misma nota con la misma duración; si un evento de note-on MIDI se activa un poco antes que el note-off MIDI del evento anterior, será detenido por el note-off. Este es un error conocido y está siendo investigado.
                                Sincronización de mensajes MIDI y mensajes FoxDot</p>
                                
                                <p>Si estás usando FoxDot y tu dispositivo MIDI, puedes notar que los eventos de sonido no están sincronizados. Para solucionar esto necesitas configurar manualmente el valor Clock.midi_nudge, que añade un retardo a los mensajes MIDI. Aquí hay un código de ejemplo para ayudar a sincronizar los mensajes:</p>
                                <p><code>p1 >> MidiOut([0,4])</code></p>
                                <p><code>p2 >> play ("x * ")</code></p>
                                <p><code>#El valor suele estar entre 0,15 y 0,25</code></p>
                                <p><code>Clock.midi_nudge = 0.2</code></p>
                                <p>Cuando los sonidos estén sincronizados, permanecerán sincronizados hasta la próxima vez que inicie FoxDot, ¡así que recuerde este valor!
                                </p>
 
								
								</div>
								
								</div>
								
								</div>
                    <div class="bb-item" id="item13">
						<div class="content">
							<div class="scroller">
								<h2> Usando tu propio SynthDef</h2>
                                <p>
                                    Aunque FoxDot viene con su propia gama de SynthDefs para que puedas controlarla, es posible que quieras escribir una propia o utilizar una que ya hayas creado. Esta página te muestra cómo escribir un SynthDef para usar con FoxDot. Esta página requiere un conocimiento básico de los SynthDefs de SuperCollider; si desea obtener más información, puede visitar la documentación de SuperCollider sobre el tema.</p>
                                    <p>
                                    Comencemos con un SynthDef muy básico escrito en SuperCollider hecho de una onda sinusoidal y una envolvente de percusión básica. Si también estamos controlando la amplitud y la panorámica, podría parecerse a esto:</p>
                                
                                <p><code>SynthDef.new(\sine,</code></p> 
                                <p><code>  {|amp=1, sus=1, pan=0, freq=0|</code></p> 
                                <p><code> var osc, env;</code></p>
                                <p><code>osc=SinOsc.ar(freq, mul: amp);</code></p> 
                                <p><code>    env=EnvGen.ar(Env.perc(TiempoAtaque: 0.01, releaseTime: sus), doneAction: 2);</code></p> 
                                <p><code> osc=(osc * env);</code></p> 
                                <p><code> osc = Pan2.ar(osc, pan);</code></p> 
                                <p><code>Out.ar(0, osc)}).add;</code></p>
                                
                                <p>Para activar mensajes de sintetizador en SuperCollider desde FoxDot, sólo necesitas darle a FoxDot una referencia al SynthDef. Puede hacerlo ejecutando el siguiente código en FoxDot:</p>
                                
                                
                                
                                <p><code>sine = SynthDef("sine")</code></p> 
                                
                                <p>El seno a la izquierda es como FoxDot se referirá al sintetizador, y el "seno" entre paréntesis a la derecha es el nombre del SynthDef en SuperCollider. No tienen que tener el mismo nombre, pero tiene sentido mantener la coherencia. Una vez que tengas un SynthDef sinusoidal en FoxDot, puedes usarlo con un objeto de reproductor como cualquier otro.</p>
                                
                                
                                <p><code> p1 >> sine([0, 4, 6, 7], dur=1/2)</code></p>
                                
                                <p>Sin embargo, si intentas usar efectos en FoxDot, te darás cuenta de que no funciona:</p>
                                <p><code>p1 >> sine([0, 4, 6, 7], dur=1/2, shape=0.5, chop=4)</code></p> 
                                
                                <p>Para poder "encadenar" los efectos es necesario hacer algunos ajustes en el SuperCollider SynthDef. En primer lugar, es necesario poder suministrar al SynthDef un argumento de bus, que almacenará la salida del sintetizador a medida que se añadan efectos. Luego necesitas usar In.kr para el valor de frecuencia (en realidad lo estás leyendo desde un bus, no lo estás suministrando directamente) y luego ReplaceOut.ar en vez de Out.ar en la última línea para que escribamos la señal de audio al bus de efectos en vez de al dispositivo de audio de tu computadora. Tu nuevo SynthDef debería ser algo así:</p>
                                
                                <p><code>SynthDef.new(\sine,</code></p> 
                                <p><code>{|amp=1, sus=1, pan=0, freq=0, bus=0|</code></p> 
                                <p><code>var osc, env;</code></p>
                                <p><code>freq = In.kr(bus, 1;</code></p>
                                <p><code>osc=SinOsc.ar(freq, mul: amp);</code></p> 
                                <p><code>env=EnvGen.ar(Env.perc(attackTime: 0.01, releaseTime: sus), doneAction: 0);</code></p>
                                <p><code>osc=(osc * env);</code></p> 
                                <p><code>  osc = Pan2.ar(osc, pan);</code></p> 
                                <p><code>ReplaceOut.ar(bus, osc)}).add;</code></p> 
                                
                                <p>Asegúrese de que cualquier argumento doneAction esté en 0 para que el nodo no se encuentre inmediatamente. Efectos como reverberación o eco requieren que el sintetizador no se suelte hasta más tarde. Ahora intenta ejecutar el código de FoxDot desde arriba y deberías escuchar el sonido con los efectos aplicados!</p>
                                
                                
                                
                                
                                
                                <p><code>p1 >> sine([0, 4, 6, 7], dur=1/2, shape=0.5, chop=4)</code></p> 
                                
                                
                                
                                
                                
                              
                                
                                
                                
                                
                                
                                
                                
                                
								
								</div>
								
								</div>
								
								</div>
                    <div class="bb-item" id="item14">
						<div class="content">
							<div class="scroller">
								<h2> Metodos de patrones</h2>
 
                                <p>Esta es una lista no documentada de métodos que pueden ser usados con objetos Pattern.</p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>shuffle(n=1)</h3>
                                
                                <p>Devuelve el patrón con su contenido en un orden aleatorio y n es el número de permutaciones:</p>
                                  
                                <p><code># Una sola permutación de shuffle</code></p> 
                                <p><code>print(P[0, 1, 2, 3].shuffle())</code></p>
                                <p><code>P[0, 3, 2, 1]</code></p> 
                                <p><code># Dos permutaciones</code></p>
                                <p><code>print(P[0, 1, 2, 3].shuffle(2))</code></p> 
                                <p><code>P[3, 1, 2, 0, 2, 1, 3, 0]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3> reverese()</h3>
                                
                                <p>Devuelve el patrón con su contenido en orden inverso. Los patrones / grupos anidados son *no* invertidos. Use <code>Pattern.mirror </code>para obtener ese comportamiento:</p>
                                
                                <p><code># Invierte el orden</code></p>
                                <p><code>P[0, 1, 2, 3].reverse()</code></p> 
                                <p><code>P[3, 2, 1, 0]</code></p>
                                <p><code># El patrón anidado no se invierte cuando se usa "reverse"</code></p> 
                                <p><code>P[[0, 4], 3, 2, 1].reverse()</code></p>
                                <p><code>P[1, 2, 3, P[0, 4]]</code></p>
                                <p><code># Usando mirror *does* reverse the nested patron</code></p> 
                                <p><code>P[[0, 4], 3, 2, 1].mirror()</code></p>
                                <p><code>P[1, 2, 3, P[4, 0]]</code></p> 
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>mirror()</h3>
                                
                                <p>Devuelve un patrón con su contenido en orden inverso, incluyendo patrones y grupos anidados:</p>
                      
                                <p><code># Invierte el orden</code></p>
                                <p><code>P[3, 2, 1, 0]</code></p>
                                <p><code># Invertir patrones anidados y grupos</code></p> 
                                <p><code>P[[0, 1], 2, 3, (4, 5)].mirror()</code></p>
                                <p><code>P[P(5, 4), 3, 2, P[1, 0]]</code></p> 
                                
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>sort(*args, **kwargs)</h3>
                                <p>Devuelve un patrón con los valores ordenados. Los args y **kwargs son los que se suministran a la función ordenada integrada de Python pero esto devuelve un Patrón en lugar de una lista.</p>
                                <p><code># Ordenar en orden ascendente</code></p>
                                <p><code>print(P[1, 3, 2, 0].sort())</code></p>
                                <p><code>P[0, 1, 2, 3]</code></p> 
                                <p><code># Ordenar por longitud del artículo</code></p>
                                <p><code>print(P[(1, 2), (3,), (4, 5, 6, 7), (8, 9, 10)].sort(key=lambda x: len(x)))</code></p> 
                                <p><code>P[P(3), P(1, 2), P(8, 9, 10), P(4, 5, 6, 7)]</code></p>
                                
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>stutter(n=2)</h3>
                                <p>Devuelve un nuevo patrón con cada valor repetido n número de veces. Si n es un patrón en sí mismo, entonces cada valor se repite por el número en el mismo índice en el patrón dado.</p>
                                
                                
                                <p><code># Tartamudean cada valor 3 veces</code></p>
                                <p><code>print(P[0, 1, 2, 3].stutter(3))</code></p> 
                                <p><code>P[0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3]</code></p>
                                <p><code># Tartamudea cada dos valores por dos</code></p> 
                                <p><code>print(P[0, 1, 2, 3].stutter([1, 2]))</code></p>
                                <p><code>P[0, 1, 1, 2, 3, 3]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>arp(seq)</h3>
                                
                                <p>Devuelve un nuevo patrón con cada elemento repetido len(seq) veces e incrementado por los valores en seq. Útil para arpegiar.</p>
                                
                                <p><code># Tartamudea de 2 en 2 y añade 4 a cada segundo de valor.</code></p> 
                                <p><code>print(P[0, 1, 2, 3].arp([0, 4]))</code></p>
                                <p><code>P[0, 4, 1, 5, 2, 6, 3, 7]</code></p> 
                                
                                
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>splice(seq, *seqs)</h3>
                                <p>Toma uno o más patrones para "empalmar" en el patrón original. El nuevo patrón devuelto se compone de los valores del original y de las secuencias dadas de forma alternada.</p>
                                
                                
                                <p><code># Alternando entre dos secuencias</code></p>
                                <p><code>print(P[0, 1, 2, 3].splice([4, 5, 6, 7]))</code></p>
                                <p><code>P[0, 4, 1, 5, 2, 6, 3, 7]</code></p> 
                                <p><code># Alternando entre tres secuencias</code></p>
                                <p><code>print(P[0, 2, 4].splice([1, 3, 5],[6, 7, 8]))</code></p> 
                                <p><code>P[0, 1, 6, 2, 3, 7, 4, 5, 8]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>invert()</h3>
                                
                                <p>Crea una versión invertida del patrón restando sus valores del valor más grande del patrón, de modo que el valor más grande del patrón se convierte en el más pequeño (y viceversa) y se intercambia la diferencia entre otros valores y el mínimo/máximo:</p>
                                
                                
                                <p><code>print(P[2, 5, 1, 11].invert())</code></p>
                                <p><code>P[10, 7, 11, 1]</code></p>
                                <p><code># Invertir una secuencia lineal lo invertirá</code></p> 
                                <p><code>print(P[0, 1, 2, 3].invert())</code></p>
                                <p><code>P[3, 2, 1, 0]</code></p> 
                                
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>shufflets(n = 4)</h3>
                                
                                <p>Devuelve un nuevo patrón que contiene el patrón original como un PGroup en orden aleatorio de longitud n.</p>
                                
                                
                                <p><code>print(P[0, 1, 2, 3].shufflets(3))</code></p>
                                <p><code>P[P(2, 3, 1, 0), P(3, 2, 0, 1), P(2, 1, 0, 3)]</code></p>
                                
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>pivot(i)</h3>
                                <p>Devuelve un nuevo patrón que es una versión invertida del original pero girado de forma que el elemento en el índice i sigue estando en el mismo lugar.</p>
                                
                                <p><code># En un patrón de longitud 5, un pivote a 2 mantendrá el elemento del medio en el mismo lugar</code></p>
                                <p><code>print(P[5, 1, 6, 2, 3].pivot(2))</code></p> 
                                <p><code>P[3, 2, 6, 1, 5]</code></p>
                                
                                
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>accum(n=Ninguna)</h3>
                                <p>Devuelve un patrón que es equivalente a la lista de sumas de ese patrón hasta ese índice (el primer valor es siempre 0). El argumento n especifica la longitud del nuevo patrón. Cuando n es Ninguno entonces el nuevo patrón toma la longitud del original.</p>
               
                                <p><code>#Acumulación de una serie de valores</code></p> 
                                <p><code>print(P[1, 2, 3, 4].accum())</code></p>
                                <p><code>P[0, 1, 3, 6]</code></p>
                                <p><code># El nuevo valor puede ser más largo que el original</code></p>
                                <p><code>imprimir(P[1, 2, 3, 4].accum(8))</code></p> 
                                <p><code>P[0, 1, 3, 6, 10, 11, 13, 16]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>stretch(size)</h3>
                                <p>Devuelve un patrón que se repite hasta que la longitud es igual al tamaño.</p>
                                
                                
                                <p><code># Estira el patrón</code></p> 
                                <p><code>print(P[1, 2, 3, 4].stretch(6))</code></p>
                                <p><code>P[1, 2, 3, 4, 1, 2]</code></p> 
                                <p><code>El tamaño puede ser menor que la longitud del original.</code></p>
                                <p><code>print(P[1, 2, 3, 4].stretch(3))</code></p>
                                <p><code>P[1, 2, 3]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>trim(size)</h3>
                                <p>Como estirar pero la longitud no puede exceder la longitud del patrón original.</p>
                                
                                <p><code># Recorta el patrón a la longitud 3</code></p> 
                                <p><code>print(P[1, 2, 3, 4, 5].trim(3))</code></p>
                                <p><code>P[1, 2, 3]</code></p> 
                                <p><code># Se ignoran los valores de tamaño mayores que la longitud</code></p>
                                <p><code>print(P[1, 2, 3, 4, 5].trim(10))</code></p> 
                                <p><code>P[1, 2, 3, 4, 5]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>ltrim(tamaño)</h3>
                                <p>Como recortar, pero elimina elementos del inicio del patrón, no del final.</p>
                                
                                
                                <p><code>print(P[1, 2, 3, 4, 5].ltrim(3))</code></p>
                                <p><code>P[3, 4, 5]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>loop(n)</h3>
                                <p>Repite el patrón n veces. Útil cuando se encadenan múltiples patrones. Los patrones anidados se tienen en cuenta cuando se realiza el bucle.</p>
                                <p><code># Repite el patrón dos veces</code></p> 
                                <p><code>print(P[0, 1, 2, 3].loop(2))</code></p>
                                <p><code>P[0, 1, 2, 3, 0, 1, 2, 3]</code></p> 
                                <p><code># Repite dos veces y encadena con otro patrón</code></p>
                                <p><code>print(P[0, 1, 2].loop(2) | P[7, 6])</code></p> 
                                <p><code>P[0, 1, 2, 0, 1, 2, 7, 6]</code></p>
                                <p><code># Looping with nested patterns expands the nests</code></p>
                                <p><code>print(P[0,[1, 2]].loop(2))</code></p>
                                <p><code>P[0, 1, 0, 2, 0, 1, 0, 2]</code></p> 
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>duplicate(n)</h3>
                                <p>Como el bucle pero retiene los patrones anidados de tal manera que el primer valor en los nidos se utiliza en la primera iteración a través de la secuencia duplicada, etc.</p>
                                
                                
                                <p><code>#Mantenga los valores anidados al duplicar</code></p>
                                <p><code>print(P[0,[1, 2]].duplicate(2))</code></p> 
                                <p><code>P[0, P[1, 2], 0, P[1, 2]]</code></p><p><code></code></p> 
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>iter</h3>
                                
                                <p>Como el bucle, pero no tiene en cuenta los patrones anidados al calcular la longitud.</p>
                                
                                <p><code>print(P[0,[1, 2]].iter(2))</code></p>
                                <p><code>P[0, 1, 0, 2]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>swap(n)</h3>
                                <p>Cambia los lugares de los valores en el patrón. Cuando n es 2 entonces los valores uno al lado del otro son intercambiados, cuando n es 3 entonces los valores siguientes pero 1 son intercambiados, y así sucesivamente.</p>
                                
                                <p><code># Intercambiar valores uno al lado del otro</code></p>
                                <p><code>print(P[0, 1, 2, 3].swap(2))</code></p> 
                                <p><code>P[1, 0, 3, 2]</code></p>
                                <p><code># Intercambiar valores separados por un paso</code></p> 
                                <p><code>print(P[0, 1, 2, 3, 4, 5].swap(3))</code></p>
                                <p><code>P[2, 1, 0, 5, 4, 3]</code></p> 
                                
                                  <hr style= "border-color: #4e7c5c; width:90%"> 
                                <h3>rotate(n)</h3>
                                <p>Devuelve un patrón con los valores del patrón original desplazados a la izquierda en orden por n número de lugares. Los números negativos desplazan los valores a la derecha.</p>
                                
                                
                                
                                
                                <p><code>#Gira a la izquierda a la 1</code></p>
                                <p><code>print(P[0, 1, 2, 3].rotate(1))</code></p>
                                <p><code>P[1, 2, 3, 0]</code></p>
                                <p><code># Gira a la derecha por 1</code></p> 
                                <p><code>print(P[0, 1, 2, 3].rotate(-1))</code></p>
                                <p><code>P[3, 0, 1, 2]</code></p> 
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>sample(n)</h3>
                                
                                <p>Devuelve un patrón de n-longitud con valores seleccionados aleatoriamente del patrón original. La n</p>
                                
                                
                                <p><code>print(P[0, 1, 2, 3].sample(3))</code></p> <p><code></code></p>
                                <p><code>P[3, 2, 0]</code></p>
                                
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>palindrome()</h3>
                                
                                <p>Añade el reverso de un patrón sobre sí mismo de tal manera que crea un palíndromo de números.</p>
                                
                                <p><code>print(P[0, 1, 2, 3].palindrome())</code></p>
                                <p><code>P[0, 1, 2, 3, 3, 2, 1, 0]</code></p> 
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                
                                <h3>alt(seq)</h3>
                                
                                <p>Reemplaza el patrón con el de seq. Es útil si desea utilizar un patrón alternativo y asignarlo utilizando cada método.</p>
                                
                                
                                <p><code># Reemplaza el patrón</code></p>
                                <p><code>print(P[0, 1, 2, 3].alt([4, 5]))</code></p> 
                                <p><code>P[4, 5]</code></p> 
                                <p><code>#Útil cuando se usa con un Reproductor</code></p>
                                <p><code>p1 >> pads([0, 1, 2, 3]).every(6, "alt", P[4, 5, 6, 7])</code></p>
                                
                                
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3> norm()</h3>
                                <p>Devuelve un patrón con todos los valores normalizados de forma que cada valor del nuevo patrón esté entre 0 y 1.</p>
                                <p><code>print(P[0, 1, 2, 3].norm())</code></p>
                                <p><code>P[0.0, 0.3333333333333333, 0.6666666666666666, 1.0]</code></p> 
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>undup()</h3>
                                
                                <p>Elimina cualquier valor duplicado consecutivo para que no haya valores repetidos en el patrón.</p>
                                <p><code>print(P[0, 1, 1, 1, 1, 2, 2, 3].undup())</code></p>
                                <p><code>P[0, 1, 2, 3]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>limit(func, value)</h3>
                                <p>Devuelve un nuevo patrón generado añadiendo valores desde el original hasta que func(pattern) exceda el valor. El argumento func debe ser una función válida, como len o suma.</p>
                                <p><code># Crea un patrón cuya suma no sea mayor de 7</code></p> 
                                <p><code>print(P[0, 1, 2, 3].limit(sum, 7))</code></p>
                                <p><code>P[0, 1, 2, 3, 0, 1]</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>replace(sub, repl)</h3>
                                <p>Devuelve un nuevo patrón con valores iguales a sub reemplazado por repl.</p>
                                
                                <p><code>#Sustituye los valores de 0 por 4</code></p>
                                <p><code>print(P[0, 1, 2, 3].replace(0, 4))</code></p> 
                                <p><code>P[4, 1, 2, 3]</code></p>
                                <p><code># También reemplaza valores en grupos y patrones anidados</code></p> 
                                <p><code>print(P[0, (1, 0), 2,[3, 0]].replace(0, 4))</code></p>
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>submap(mapping)</h3>
                                <p>Similar a reemplazar pero requiere un diccionario de sub para replicar valores y reemplazar múltiples ítems.</p>
                                
                                
                                <p><code># Sustituir 0 por 4 y 1 por 5</code></p>
                                <p><code>print(P[0, 1, 2, 3].submap({0: 4, 1: 5}))</code></p>
                                <p><code>P[4, 5, 2, 3]</code></p>
                                <p><code>También funciona con valores anidados, etc.</code></p> 
                                <p><code>print(P[0, (1, 0), 2,[3, 0]].submap({0: 4, 1: 5}))</code></p>
                                <p><code>P[4, P(5, 4), 2, P[3, 4]]</code></p> 
                                   <hr style= "border-color: #4e7c5c; width:90%">
                                <h3>layer(method, *args, **kwargs)</h3>
                                
                                <p>Cierra el patrón original con sí mismo pero con el método llamado en sí mismo, que debe ser un nombre de cadena de un método de patrón válido (similar a Player.every). Sin embargo, el argumento del método también puede ser una función (ejemplo a continuación).</p>
                                
                                <p><code># Patrón con cremallera con su reverso</code></p>
                                <p><code>print(P[0, 1, 2, 3].layer("reverse"))</code></p>
                                <p><code>P[P(0, 3), P(1, 2), P(2, 1), P(3, 0)]</code></p>
                                <p><code> # Patrón con cremallera con swap(2) llamado en él</code></p>
                                <p><code>print(P[0, 1, 2, 3].layer("swap", 2))</code></p> 
                                <p><code>P[P(0, 1), P(1, 0), P(2, 3), P(3, 2)]</code></p>
                                <p><code># Zipped with a function multiplicando los valores por 2</code></p> 
                                <p><code>print(P[0, 1, 2, 3].layer(lambda x: x + 2))</code></p> 
                                <p><code>P[P(0, 2), P(1, 3), P(2, 4), P(3, 5)]</code></p>
                                <p><code># Esto es equivalente a abajo:</code></p>
                                <p><code>print(P[0, 1, 2, 3].layer("__add__", 2))</code></p>
                                <p><code>P[P(0, 2), P(1, 3), P(2, 4), P(3, 5)]</code></p> 
                           

                                <h3>every</h3>     
                                <h3>map</h3>    
                                <h3>extend</h3>     
                                <h3>pipe</h3>    
                                <h3>zip</h3>    
                                <h3>offadd</h3>
                                <h3>offmul</h3>
                                <h3>offlayer</h3>
                                <h3>amen</h3>
                                
                                
                            
								
								</div>
								
								</div>
								
								</div>
                    <div class="bb-item" id="item15">
						<div class="content">
							<div class="scroller">
								<h2> Renderizador de voz </h2>
                                
                                <p>El renderizador de voz es una herramienta que enrobustece más el desempeño de foxdot, desarrollado por Matthias Gatti, anexada al master branch de foxdot en agosto de 2018, en algunas ocasiones no va correr bien por falta de algunas dependencias y algunos problemas con la version que se descarga del pip</p>
                                
                                <p>version  v0.7.1 fixes and updates</p>
                                
                                <h4>   Requerimientos </h4>
                                <p>sudo apt-get install musescore </p>
                                <p><code>sudo pip install MIDIUtil</code></p>
                                
                              <p>  El comando para poner a correr el renderizador ejecutamos los siguientes comandos</p>
                                <p><code>from .Extension.VRender import vrender</code></p> 
                                <p>este primer comando importa la vrender </p>
                                <p><code>vrender ("a1",lyrics=" hey you smoke weed" tempo=160, dur=[1,2,3,4], notes=[4,3,2,1] )</code></p>
                                
                                <p>este comando crea un archivo .wav con una voz que dice hey you smoke weed llamado a1 ubicado en la carpeta loop de samples </p>
                                <p>notese en la terminal donde se ejecuta foxdot que empieza a correr el script</p>
                                 <p><code>j1 >> loop("a1", dur=16)</code></p>
                                <p> este comando ejecuta nuetra voz </p>
                                
                                <iframe src="https://www.facebook.com/plugins/video.php?href=https%3A%2F%2Fwww.facebook.com%2Fnoisk8%2Fvideos%2F1931605150242008%2F&show_text=1&width=560" width="560" height="512" style="border:none;overflow:hidden" scrolling="no" frameborder="0" allowTransparency="true" allow="encrypted-media" allowFullScreen="true"></iframe>
                                
                                <p>También tuve quereemplazar las rutas en el arcivo constants.py ubicado en la carpeta Extensions.</p>
                                
                                <p></p> 
                     
                               
                                <p><code>    # Constants</code></p>
                                <p><code>FILES_ROOT = "/home/xxx/FoxDot/FoxDot/lib/Extensions/VRender/tmp/"</code></p> 
                                <p><code>LAST_MIDI = FILES_ROOT + "last_midi_generated_by_vrender.mid"</code></p>
                                <p><code>VOICE_XML_ORIGINAL=FILES_ROOT + "last_voice.musicxml"</code></p> 
                                <p><code>VOICE_XML_PROCESSED=FILES_ROOT+"last_voice.xml"</code></p> <p><code></code></p> 
                                <p><code>WAVS_ROOT = "/home/xxx/FoxDot/FoxDot/snd/_loop_/"</code></p>
                                <p><code>LAST_VOICE_WAV = WAVS_ROOT + "last_voice_generated.wav"</code></p> 
                                <p><code></code></p>
                                <p>reemplazar xxx por tu nombre de usuario </p>
 
								
								</div>
								
								</div>
								
								</div>
                    <div class="bb-item" id="item16">
						<div class="content">
							<div class="scroller">
                                <h2>Problemlas frecuentes</h2>
                                
                                
                                
                                
                                
                                
                                
                            </div>
                    </div>
                    </div>
                
                
                
                
                
                
                
                
                
                
                
                </div>
				
				
				
				
				<nav>
					<span id="bb-nav-prev">&larr;</span>
					<span id="bb-nav-next">&rarr;</span>
				</nav>

				<span id="tblcontents" class="menu-button">Table of Contents</span>

			</div>
				
		</div><!-- /container -->
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
		<script src="js/jquery.mousewheel.js"></script>
		<script src="js/jquery.jscrollpane.min.js"></script>
		<script src="js/jquerypp.custom.js"></script>
		<script src="js/jquery.bookblock.js"></script>
		<script src="js/page.js"></script>
		<script>
			$(function() {

				Page.init();

			});
		</script>
	</body>
</html>
