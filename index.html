<!DOCTYPE html>
<html lang="en" class="no-js">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"> 
		<meta name="viewport" content="width=device-width, initial-scale=1.0"> 
		<title>FoxDot en español</title>
		<meta name="description" content="Fullscreen Pageflip Layout with BookBlock" />
		<meta name="keywords" content="fullscreen pageflip, booklet, layout, bookblock, jquery plugin, flipboard layout, sidebar menu" />
		<meta name="FD" content="FoxDot" />
		<link rel="shortcut icon" href="../favicon.ico"> 
		<link rel="stylesheet" type="text/css" href="css/jquery.jscrollpane.custom.css" />
		<link rel="stylesheet" type="text/css" href="css/bookblock.css" />
		<link rel="stylesheet" type="text/css" href="css/custom.css" />
		<script src="js/modernizr.custom.79639.js"></script>
	</head>
	<body>
		<div id="container" class="container">	

			<div class="menu-panel">
				<h3>Tabla de Contenidos</h3>
				<ul id="menu-toc" class="menu-toc">
					<li class="menu-toc-current"><a href="#item1">FoxDot</a></li>
					<li><a href="#item2">Instalación</a></li>
					<li><a href="#item3">Usando FoxDot</a></li>


					<li><a href="#item4"> Clock</a></li>
					<li><a href="#item5">SyntDefs</a></li>
					<li><a href="#item6">Samples</a></li>
					<li><a href="#item7">Efectos ~ Atributos</a></li>
					<li><a href="#item8"> Patrones </a></li>
					<li><a href="#item9"> Generador de Patrones </a></li>
					<li><a href="#item10"> Escalas </a></li>
					<li><a href="#item11"> Variables </a></li>
<li><a href="#item12"> Grupos  </a></li>

				</ul>
				<div>
					<a href="https://foxdot.org/">Pagina Oficial de FoxDot </a>
					<a href="https://tympanus.net/codrops/?p=12795"> </a>
				</div>
			</div>

			<div class="bb-custom-wrapper">
				<div id="bb-bookblock" class="bb-bookblock">
					<div class="bb-item" id="item1">
						<div class="content">
							<div class="scroller">
								<h2>Livecoding con Python y Supercollider</h2>
  	<img src="img/111.png" alt="FoxDot" >
								
								
						<p>FoxDot, se creó en 2015 para intentar abrir las vías de Live Coding para los usuarios que pueden ser nuevos en la programación y desean usarla para crear música rápida y fácilmente. FoxDot es una biblioteca de Python fácil de usar que crea un entorno de programación interactiva y habla con el potente motor de síntesis de sonido, llamado SuperCollider para hacer música. FoxDot programa eventos musicales de una manera sencilla y fácil de usar que hace que la codificación en vivo sea fácil y divertida tanto para los recién llegados como para los veteranos de programación.</p>
						
						

								<h3> Funcionamiento </h3>

								<p>FoxDot utiliza a supercollider como motor sonoro de sus syntetizadores, los interpreta a partir de sintaxis de python y con la liberria tcl crea el ide que utilizamos para depositar el código</p>
								
								<img src="img/FoxDotRun.png" alt="FoxDot" width="800" height="500" >

								<p> </p>

								<p> </p>

	
							</div>
						</div>
					</div>
					
					
					
					<div class="bb-item" id="item2">
						<div class="content">
							<div class="scroller">
								<h2>Instalación</h2>
								
								<p> Esta documentación de instalción surge tras las necesidad de tener más claridad para instalar los softwares o paquetes necesarios para que FoxDot funcione correctamente en las diversas plataformas. </p>
								
									<h3> Linux </h3>

<p> Para linux puedes utilizar este <em> <a href=" https://github.com/Noisk8/InstalandoFoxDot-En-linux" target="_blank"> script</a> para agilizar el proceso de instalación. Recuerda ver las notas del repositorio para ver todos los componentes de instalación </em></p>									
								

	<h3> Windows </h3>
	
								<p> 1 Descargar <em> <a href="https://supercollider.github.io/download " target="_blank"> SuperCollider </a> En una versión superior a la 3.7</em></p>	
								
								<p> 2 Descargar <em> <a href=" https://www.python.org/downloads/windows" target="_blank"> Python </a> en lo posible MSI instaler (para chekar que incluye pip)</em></p>	
								
								<p> 3 instalar FoxDot vía CMD</p>

<p> 3.1 Abrimos CMD</p>
                       <img src="img/1.png" alt="FoxDot">	
                       
                    <p> 3.2  Accedemos a la carpeta donde estan ubicados los scripts de python </p> 
                       
                       <img src="img/3.png" alt="FoxDot" >
                       
                       	<p>3.3 Instalamos pip  </p>
                       
					   <img src="img/4.png" alt="FoxDot" >
					   
					   <p> 4 Descargar <em> <a href=" https://git-scm.com/download/win" target="_blank"> Git </a> esto para poder instalar posteriormente los quarks en supercollider</em></p>	
                                
                        <p> Para más info sobre la instalación en windows  <em> <a href="https://www.youtube.com/watch?v=sfwTC1e05yc&t=3s " target="_blank"> Ver este vídeo  </a>hecho por Steve Man</em></p>
					 
					 	
					   
					  <h3> Mac OS </h3>
					  
					  <p> 1 Descargar <em> <a href="https://supercollider.github.io/download " target="_blank"> SuperCollider </a> En una versión superior a la 3.7</em></p>
					 	<p> 2 Descargar <em> <a href="https://www.python.org/downloads/mac-osx/" target="_blank"> Python 2.7</a>  o superior </em></p>
					 	
					 			
										 	<p> 3 Descargar <em> <a href=" https://git-scm.com/download/mac" target="_blank"> Git</a> esto para poder instalar posteriormente los quarks en supercollider </em></p>
										 	
					 	<p> 4 Instalar pip </p>	 
					 	
					 	<p> 4.1 descargamos el script get_pip | Abrimos la terminal y ejecutamos el comando </p>
					 	
					 	<p> curl -O https://bootstrap.pypa.io/get-pip.py </p>
					 	
					 	<p> 4.2 ejecutamos el scrip con el comando </p>

						<p> python get-pip.py </p>	
						
						<p> 5 instalar FoxDot con el siguiente comando </p>

								<p> sudo pip install FoxDot </p>

<p> 6 descargar el repositorio de Foxdot de github e instarlo  </p>	

<p> git clone https://github.com/Qirky/FoxDot.git </p> 		

<p> 6.1 entramos a la carpeta de FoxDot e instalamos FoxDot </p>	

<p> cd FoxDot </p>

<p> sudo python setup.py install </p> 		
								
								<p>  </p>

								<h5> Para todas las plataformas </h5>
								
								<p> Despues de tener Supercollider, python y pip procedemos a abrir supercollider y de a una ejecutamos (shift + enter ) las siguientes lineas </p>
								
								<p> Quarks.install("https://github.com/Qirky/FoxDotQuark.git") </p>
								<p> Quarks.install("https://github.com/supercollider-quarks/BatLib.git") </p>
								
								
							</div>
						</div>
					</div>
					<div class="bb-item" id="item3">
						<div class="content">
							<div class="scroller">
								<h2> Introducción </h2>
								
								<h3> Cómo abrir FoxDot? </h3>
								
								<h4>  Linux </h4>

<p> Para linux sigue las instrucciones del <em> <a href=" https://github.com/Noisk8/InstalandoFoxDot-En-linux" target="_blank"> Repositorio</a>  </em></p>									

<h4> Windows </h4>

<p> 1 Abre Supercollider </p>

<p> 1.2 Ejecuta (shift + enter) el siguiente comando </p> 

<p> FoxDot.start <p>

<p> 2 abre el cmd y dirigete hasta la carpeta de python </p>

<p> 2.1 ejecuta python -m FoxDot </p>

<img src="img/5.png" alt="FoxDot" >

<p> </p>
								
	<h4> Mac OS </h4>			
						<p> 1 Abre Supercollider </p>

<p> 1.2 Ejecuta (shift + enter) el siguiente comando </p> 

<p> FoxDot.start <p>

<p> 2 Abre una terminal y dirigete hasta la carpeta donde clonaste el repositorio de FoxDot </p>

<p> cd FoxDot/ </p> 

<p> 2.1  ejecuta python -m FoxDot </p>	

<p> python -m FoxDot </p> 

<h3> Ejecutando lineas en FoxDot </h3>

<p> para hacer sonar  cualesquier linea de código en FoxDot solo basta con presionar shift + enter sobre la linea deseada </p>	
							
								<h2> Tocando Notas  </h2> 
								<p> En FoxDot, todos los nombres de variables de dos caracteres están reservados para objetos de reproductor, como 'p1' </p>
<p> La creación de un objeto de reproductor sin argumentos reproducirá una sola nota en el medio C, de forma predeterminada, repetidamente hasta que se detenga. </p>
<p>  Use >> para asignarle uno de estos objetos a un reproductor así:</p>

								<p> p1 >> pluck() </p>

								<p> para detener el objeto p1  simplemente  </p>

								<p> p1.stop()</p>

								<p> El >> en Python generalmente se reserva para un tipo de operación, como + o -, pero no es el caso en FoxDot.  </p>

								<p> Si un usuario vuelve a ejecutar el código, FoxDot actualizará p1 en lugar de crear un PlayerObject, </p>

								<p> lo que significa que puede hacer cambios en su música usando solo una línea de código. </p>
								
								<p>Si ahora le das algunos argumentos al objeto de tu reproductor, puedes cambiar las notas que se están reproduciendo. </p>

								<p> El primer argumento debería ser el grado de la nota que se tocará</p>
								
								<p>  (predeterminado es la nota más baja de octava 5 de la escala principal) y no necesita ser especificado por nombre. </p>
								
								<p> Python, como la mayoría de los lenguajes de programación, que usa indexación cero cuando se accede a valores en una matriz</p>
								
								<p>  lo que significa que 0 se refiere a la primera nota de la escala. </p>
								
								<p> Dale a tu reproductor las instrucciones para hacer música con su Synth. </p>
								
								<p> El primer argumento es la nota de la escala para jugar. El siguiente código </p>
								
								<p> Reproduce las primeras tres notas de la escala predeterminada (major) al repetir.</p>
								
								<p> Para una nota simple </p>
								
								<p>p1 >> pluck(0) </p>
								
								<p> O una lista de Notas</p>
								
								<p> p1 >> pluck([0,1,2]) </p>
								
								
								<p> Pero necesitarás especificar cualquier otra cosa que quieras cambiar ... </p>
								
								<p>  Como la duración de las notas o la duración de cada nota </p>
								
								<p> p1 >> pluck ([0,0,0], dur = [1,2,3]) </p>
								
								<p> O amplitud, el "volumen" de cada nota</p>
								
								<p> p1 >> pluck ([0,0,0], amp = [1,2,3]) </p>
								
								<p> Si la segunda lista, el amplificador en este ejemplo, es demasiado larga, entonces la primera lista, el grado, simplemente repite 1 para cada una de la otra lista. </p>
								
								<p>p1 >> pluck ([0,2,4], amp = [1,2,3,1,5])
 </p>
								
								<p> Más claramente, todas las listas, solo avanzan en uno independientemente de la duración. </p>
								
								
								<p> p1 >> pluck ([0,2,4], dur = [1,2], amp = [1,2,3,1,5]) </p>
								<p> Los argumentos pueden ser enteros, puntos flotantes, fracciones, listas, </p>
								
								<p>  tuplas, o una mezcla
 </p>
								<p>p1 >> pluck ([0,0,0], dur = 2)  </p>
								
								<p>p1 >> pluck ([0,0,0], dur = 1,743) </p>
								<p> p1 >> pluck ([0,0,0], dur = [0.25,0.5,0.75]) </p>
								
								<p> p1 >> desplume ([0,0,0], dur = [1 / 4,1 / 2,3 / 4]) </p>
								<p> p1 >> pluck ([0,0,0], dur = [1 / 4,0.25,3]) </p>
								
								<p> Las listas de valores se repiten a medida que el reproductor reproduce notas </p>
								<p> La siguiente duración equivale a: 1,2,3,1,4,3</p>
								
								<p>  Si aún no entiendes esto, no te preocupes, más sobre los patrones en el tutorial de patrones</p>
								<p> p1 >> pluck ([0,0,0], dur = [1, [2,4], 3]) </p>
								
								<p>  Los valores en tuplas se usan simultáneamente, es decir, p1 tocará 3 notas individuales, luego un acorde de 3 juntas al mismo tiempo.</p>
								<p> p1 >> pluck ([0,2,4, (0,2,4)])</p>
								
								<p>
También puede asignar valores a los atributos de los objetos del reproductor directamente </p>
				<p> p1.oct = 5</p>	

<p> Para ver todos los nombres de los atributos del >>, solo ejecuta </p>
 
 <p> print (Player.get_attributes ()) </p>


<p>  Juega solo este >>, silenciando a los demás </p>
<p>p1.solo () # se predetermina a 1 </p>

<p> Y desactivar el solo </p>
 <p>p1.solo (0) </p>

<p> Parar (no solo silenciar) a los otros >> </p>
<p>p1.only () </p>

<p> de programar varios >>  para hacer cosas
 Esto le dirá a p1 que invierta las notas cada 4 tiempos </p>
<p> p1 >> pads ([0,2,4,6]) </p>
<p>every (4, "reverse")</p>

 <p>Lo cual es lo mismo que: </p>
<p>p1 >> pads ([0,2,4,6]). every (4, "reverse") </p>

<p> Puedes cambiar varias cosas a la vez </p>
<p>p1.every (4, "stutter", 4, oct = 4, pan = [- 1,1]) </p>

  <p> Para detener cada llamada ... </p>

			<p>p1.never ("reverse") </p>
								
								
								<p><em>Ver <a href="https://github.com/Qirky/FoxDot/blob/master/FoxDot/demo/01_playing_notes.py" target="_blank">Archivo</a> en ingles </em></p>
							</div>
						</div>
					</div>
					<div class="bb-item" id="item4">
						<div class="content">
							<div class="scroller">
								<h2> Clock </h2>
								
								<h3> Conceptos básicos del Clock </h3>


<p> Para detener todos los objetos del >>, puede presionar Ctrl +. (Mantenga presionada la tecla Ctrl y presione el punto) Que es un atajo para el comando: </p>
<p>Clock.clear ()</p>
<p>Cambiar el tempo (esto tiene efecto en la siguiente barra) El valor predeterminado es 120 </p>
<p>Clock.bpm = 144</p>
<p>Para ver lo que está programado para ser jugado. </p>
<p>print (Reloj) </p>
<p> Para ver cuál es la latencia </p>
<p>print (Clock.latency)</p>

                                <h3> Clock avanzado </h3>

<p> Nota: No necesita ejecutar esta línea, se usa para instalar FoxDot para usuarios de Linux que usan Python 2. </p>

<p>from __future__ import print_function</p>
<p> Para ver lo que está programado para ser jugado.</p>
<p>print (Clock)</p>
<p>Para ver cuál es la latencia</p>
<p> print (Clock.latency)</p>
<p> El Clock puede programar cualquier cosa con un método __call__ usando
 Se necesita una pista de tiempo absoluto para programar una funciones
 Clock.schedule necesita saber el ritmo para invocar algo en</p>
<p>Clock.schedule ()</p>
<p> Programar un evento después de una cierta duración Clock.future necesita saber cuántos ritmos por delante para llamar a algo</p>
<p> Clock.future ()</p>
<p> Estos son equivalentes</p>
<p>Clock.schedule (Clock.now () + 4, lambda: print ("hello"))</p>
<p>Clock.future (4, lambda: print ("hello"))</p>
<p>Para programar otra cosa</p>
<p>Clock.schedule (lambda: print ("hello"))</p>
<p> Podemos llamar a algo cada n beats</p>
<p>Clock.every (4, lambda: print ("hello"))</p>
<p> Obtener el reloj actual y agregar 2. Útil para la programación.</p>
<p>Clock.now () + 2</p>
<p>Con un decorador</p>
<p> Puede crear su propia función y decorarla, para poder</p>
<p> para usarlo en un objeto .every en un >></p>
<p>@PlayerMethod </p>
<p>help de def (auto):</p>
<p> print (self.gree)</p>
<p>p1 >> pluck ([0,4]). every (3, "help")</p>
<p> Y cancelarlo con </p>
<p>p1.never ("help")</p>
                                
                                <p><em>Ver <a href="https://github.com/Qirky/FoxDot/blob/master/FoxDot/demo/07_basic_clock.py" target="_blank">Archivo</a> original</em></p>
							</div>
						</div>
					</div>
					<div class="bb-item" id="item5">
						<div class="content">
							<div class="scroller">
								<h2>SynthDefs</h2>
								
<p>FoxDot crea música dando a los objetos del reproductor un "instrumento digital" para jugar, que se llaman 'SynthDefs'. Puedes ver la lista de preinstalados 'Synths' mediante la ejecución </p>
<p> print (SynthDefs)</p>
<p>Cada uno de estos representa un objeto `SynthDef` * *. Estos objetos son entonces dado a los >> para sonar, como dar un instrumento a alguien en su orquesta.</p>
		
		

								<ul>   <li>sawbass</li>
                                    <li>karp </li>
                                    <li>gong </li>
                                    <li>varsaw </li>
                                    <li>bell </li>
                                    <li>scratch </li>
                                    <li> pulse</li>
                                    <li>audioin </li> blip 
                                    <li>pads</li>
                                    <li>rave </li>
                                    <li>donk </li>
                                    <li>saw </li>
                                    <li>orient </li>
                                    <li> creep </li>
                                    <li>growl </li>
                                    <li>marimba </li>
                                    <li>razz </li>
                                    <li>dub </li>
                                    <li>arpy </li>
                                    <li>ambi </li>
                                    <li>viola </li>
                                    <li>piano </li>
                                    <li>quin </li>
                                    <li>crunch </li>
                                    <li>noise </li>
                                    <li>star </li>
                                    <li> bass  </li>
                                    <li>dab </li>
                                    <li>dirt </li>
                                    <li>twang </li>
                                    <li>swell </li>
                                    <li>pluck </li>
                                    <li>glass </li>
                                    <li>soprano </li>
                                    <li>charm </li>
                                    <li>spark </li>
                                    <li>bug </li>
                                    <li>squish </li>
                                    <li>sitar</li> 
                                    <li>zap </li>
                                    <li>snick </li>
                                    <li>play2 </li>
                                    <li>play1 </li>
                                    <li>prophet </li>
                                    <li>ripple </li>
                                    <li>fuzz </li>
                                    <li>lazer </li>
                                    <li>klank </li>
                                    <li>nylon </li>
                                    <li>soft </li>
                                    <li>scatter </li>
                                    <li>loop </li>
</ul>


								<p><em>From <a href="http://www.gutenberg.org/ebooks/41595" target="_blank">"The Funny Side of Physic"</a> by A. D. Crabtre</em></p>
							</div>
						</div>
					</div>
					<div class="bb-item" id="item6">
						<div class="content">
							<div class="scroller">
							<h2>Samples</h2>
							<h3> Reproducción de samples incorporadas</h3>
								<p>
 FoxDot también se puede usar para secuenciar y manipular samples de audio.
 Para hacer esto, todo lo que necesitas hacer es usar el juego especial SynthDef.
 El primer argumento de la obra SynthDef debería ser una cadena de caracteres
 en lugar de una lista de números como lo haría con cualquier otro SynthDef.
 Cada personaje representa un archivo de audio diferente, que se almacena en un búfer en SuperCollider. </p>



<p>Para ver qué personaje se relaciona con qué archivo de audio, ejecuta
print (BufferManager ())
</p>
							<p> 
 Puede reproducir samples de audio en FoxDot / snd / subdirectorios utilizando el
 'play' Synth y usando una cadena de caracteres en lugar de la lista de notas.
</p>
 								<p> bd >> play ("x")
 </p>


								<p> 
 Un carácter se refiere a un sonido y el espacio en blanco se usa para silencio, por lo que
 puedes difundir los sonidos a tiempo:</p>
 
 								<p>
bd >> play ("x x x")
  </p>


								<p> 
hh >> play ("-")</p>


								<p> Puedes hacer patrones de encaje usando corchetes 
 hick juega como: "x o xo"
 </p>


								<p> 
d1 >> play ("(x) (x) o")</p>


								<p> 
 Lo siguiente es lo mismo que "------- =" </p>


								<p>  
hh >> play ("--- (- =)")
</p>

 	<p>  Colocar caracteres entre corchetes los reproducirá todo en el espacio de un tiempo
 Y se reproducirá como un personaje, no simultáneo, pero en rápida sucesión
</p>


								<p>  
d1 >> play ("x-o [-o]")
</p>



								<p> 

d1 >> play ("x-o [---]")</p>

d1 >> play ("x-o [-----]")

d1 >> play ("x-o [--------------]")


								<p> 
 y se pueden poner entre corchetes como si fueran un solo personaje. </p>


								<p> 
d1 >> play ("x [-] o (= [- o])")
</p>

	
								<p> 	
 Puede combinar los corchetes como quiera: los siguientes patrones son idénticos
</p>


								<p> d1 >> play ("x-o (- [- o])")
</p>








								<p>  

d1 >> play ("x-o [- (o)]")
</p>

 
								<p>  Las llaves acorazadas seleccionan una muestra de sonido al azar si quieres más variedad </p>
								
								
								<p> 

d1 >> play ("x-o {- = [-] [- o]}")</p>

<p>  Los soportes angulares combinan patrones para jugar simultáneamente
							
</p>

								

<!-- d1 >> play ("<jjj> <-> <jj> <V>") 


								

d1 >> play (" <X> <-> <#> <V> ") -->



								<p> Cada personaje está asignado a una carpeta de archivos de sonido y puede seleccionar diferentes samples utilizando el argumento de la palabra clave " sample" </p>


								<p> d1 >> play ("(x [-]) xu [-]") </p>

<p> d1 >> play ("(x [-]) xu [-]", sample = 1) </p>


								<p>  d1 >> play ("(x [-]) xu [-]", sample = 2) </p>


								<p> Cambiar la muestra para cada tiempo </p>
 	
								<p> d1 >> play ("(x [-]) xu [-]", sample = [1,2,3]) </p>
 
								<p>  Puedes juntar dos patrones</p>

<p> d1 >> play (P ["x-o-"] Y P ["**"]) </p>



                                <p> Y efectos de cambio aplicados a todos los patrones de capas al mismo tiempo </p>
<p> d1 >> play (P ["x-o-"] Y  P ["**"], room = 0.5) </p>


								<p>  Ejemplo del tutorial del reproductor, pero con samples en su lugar Condicionales ...</p>
 
								<p> d1 >> play ("x [-] xu [-] x", muestra = (d1.degree == "x"))</p>
		
								<p>  O cámbialo al banco de muestra 2 multiplicando </p>

								<p> d1 >> play ("x [-] xu [-] x", muestra = (d1.degree == "x") * 2) </p>
 <p> Chain multiple condicional </p>
<p>d1 >> play ("x [-] xu [-] x", muestra = (d1.degree == "x") * 2 + (d1.degree == "-") * 5)  </p>

								<p>  Que es lo mismo que</p>
                                <p>d1 >> play ("x [-] xu [-] x", sample = d1.degree.map ({"x": 2, "-": 5}))</p>


	
				
							</div>
					</div>
					</div>
					
					
					
				<div class="bb-item" id="item7">
						<div class="content">
							<div class="scroller">
								<h2>Efectos y Atributos</h2>
                                
                                
                                <p >  Referencia de atributos del reproductor </p>


                                <p> Para ver todos los atributos: </p>
                                
                                <p> print (Player.get_attributes ()) </p>

                                <p> Puede ver qué efectos están disponibles evaluando </p>
                                <p> print(FxList) </p>

                                <p>  Usemos el filtro de paso alto para un ejemplo. Puedes ver que está descrito </p>
                                <p> al igual que: </p>
                                <p>  "Fx 'highPassFilter' - args: hpr, hpf" </p>

                                <p> Cada efecto tiene un argumento "maestro" y luego argumentos secundarios. Aquí el </p>
                                
 <p> El argumento # master es "hpf" (abreviatura de filtro de paso alto) y el argumento secundario </p> 
<p>  es "hpr" (abreviatura de resonancia de paso alto). El efecto solo se agrega cuando el
El argumento # master no es cero: </p>
                                
                                <p> d1 >> suciedad ([0,4,2,1], dur = 1/2, hpf = 4000) </p>

<p>  Esto establece el filtro de paso alto a 4000 Hz por lo que solo las frecuencias en el audio </p>
                                <p> signal * above * que en realidad se escuchan. Cambiemos el valor de resonancia. Sus </p>
                                <p> el valor predeterminado es 1, así que hagámoslo más pequeño </p>
                                <p> d1 >> suciedad ([0,4,2,1], dur = 1/2, hpf = 4000) </p>

                                <p>d1 >> suciedad ([0,4,2,1], dur = 1/2, hpf = 4000, hpr = 0.3)</p>


                                <p> ¿Notar una diferencia? Podemos usar patterns / vars en nuestros efectos para hacerlos </p>
                                <p> cambian con el tiempo: </p>
<p> d1 >> suciedad ([0,4,2,1], dur = 1/2, hpf = linvar ([0,4000], 8), hpr = P [1,1,0.3] .stretch (8)) </p>



<h3> Referencia </h3>


<h4> amp - Amplitud (por defecto es 1) </h4>
<p> Establece el volumen de la nota / patrón</p>

                                <p> d1 >> play ("*", dur = 1/2, amp = 1) </p>

                                <p> Medio volumen </p>
                                <p> d1 >> play ("*", dur = 1/2, amp = .5) </p>

                                <p>  Creando un patrón con amplificador </p>
                                <p> d1 >> play ("*", dur = 1/2, amp = [1,0,1,1,0]) </p>
                                    
                                   
<h4> amplify  </h4> 
                                <p>Chagnes amp, multiplicando agasint el valor existente (en lugar de sobreescribir) </p>

                                <p> Creando un patrón con amplificador </p>
                                <p> d1 >> play ("*", dur = 1/2, amp = [1,0,1,1,0]) </p>
                                <p> d1 >> play ("*", dur = 1/2, amplificar = [. 5,1,0]) </p>

<p>  Configurar una "caída" en la música (Reproduce a volumen completo durante 28, luego 0 por 4) </p>
                                <p> p1 >> blip ([0,1,2,3], amplificar = var ([1,0], [28,4])) </p> 

<h4>bits </h4>
<p> La profundidad de bits, en número de bits, a la que se reduce la señal; </p>
<p>este es un valor entre 1 y 24 donde se ignoran otros valores. </p>
<p> Usar aplastamiento para establecer la cantidad de reducción a la velocidad de bits (por defecto es 8)

                                </p>
<h4> bitcrush</h4>
                                <p>- Ver bits </p>


<h4> chop </h4>
<p> 'Chop's la señal en trozos utilizando una onda de pulso de baja frecuencia sobre el sostenido de una nota.
</p>

<h4>cut</h4>
<p> Corta una duración </p>
<p> p1 >> desplume (P [: 8], dur = 1/2, cut = 1/8) </p>
<p> p1 >> desplume (P [: 8], dur = 1/2, cut = 1/4) </p>
<p> p1 >> pluck (P [: 8], dur = 1/2, corte = 1/2) </p>


<h4> grado </h4>
                                <p>- El grado de la nota, o tono, se puede especificar por palabra clave (también el primer posicional) </p>
<p> p1 >> blip (grado = [0,1,2,3]) </p>

<p> Lo cual es lo mismo que: </p>
<p> p1 >> blip ([0,1,2,3]) </p>

<p>  Solo reproduce la nota "raíz" del acorde </p>
<p> b1 >> bajo (p1.degree [0]) </p>

<h4>  delay </h4>
                                <p> duración de espera antes de enviar la información a SuperCollider (por defecto es 0) </p>

<p> Retrasa cada 3 notas por .1 </p> 
<p> p1 >> blip ([0,1,2,3], delay = [0,0,0.1]) </p>

<p>  Retrasa cada 3 notas por .5 </p>
<p> p1 >> blip ([0,1,2,3], delay = [0,0,0.5]) </p>

<p>  Reproduce la nota una vez por cada retraso diferente </p>
<p>p1 >> blip ([0,1,2,3], delay = (0,0.1)) </p>

<p> p1 >> blip ([0,1,2,3], delay = (0,0,25)) </p>

<p> p1 >> blip ([0,1,2,3], delay = (0, .1, .2, .3)) </p>
                                    

<h4>  dur </h4>
                                <p> - Duraciones (predeterminado para 1 y 1/2 para el Reproductor de muestra)
</p>


                            
<h4 > eco  </h4>
<p> Palabra clave del título: echo, palabra clave (s) de atributo: decaimiento </p>
<p>  Establece el tiempo de caída para cualquier efecto de eco en tiempos, funciona mejor en Sample Player (por defecto es 0) </p>
<p> Multiplicado contra el valor de sostenido </p>
<p> d1 >> play ("x-o-", echo = 0.1) </p>

<p> d1 >> play ("x-o-", echo = 0.5) </p>

<p> p1 >> pluck (P [: 8], echo = .25) </p>

<p> p1 >> pluck (P [: 8], echo = .5) </p>

<p> p1 >> pluck (P [: 8], echo = .5, decay = .5) </p>


<h4> hpf  </h4>
                                <p>  Filtro de paso alto</p>
<p> Filtra todas las frecuencias por debajo del valor dado, eliminando las frecuencias más bajas </p>

                                <p>4000 hertz </p>
<p> p1 >> pluck (P [: 8], dur = 1/2, hpf = 4000) </p>

<p>  HPF es 0 para 4 tiempos, luego 4000 para 4 tiempos </p>
                                
<p> p1 >> pluck (P [: 8], dur = 1/2, hpf = var ([0,4000], [4,4])) </p>

<p>  Cambio lineal en hpf desde 0 toma 4 tiempos para llegar a 4000, 4 tiempos de vuelta a 0 </p>
                                
 <p> p1 >> pluck (P [: 8], dur = 1/2, hpf = linvar ([0,4000], [4,4])) </p>

<p>  El cambio lineal en hpf desde 0 toma 8 tiempos para llegar a 4000, luego se restablece a 0 </p>
<p> p1 >> pluck (P [: 8], dur = 1/2, hpf = linvar ([0,4000], [8,0])) </p>

<p>  Con cambio de resonancia (el valor predeterminado es 1) </p>
<p> p1 >> pluck (P [: 8], dur = 1/2, hpf = linvar ([0,4000], [8,0]), hpr = .5) </p>

<p>  Con el cambio de resonancia como un linvar </p>
<p> p1 >> pluck (P [: 8], dur = 1/2, hpf = linvar ([0,4000], [8,0]), hpr = linvar ([0.1,1], 12)) </p>


<h4>  lpf </h4> 
                                <p> Filtro de paso bajo </p>
<p>  Filtra todas las frecuencias por encima del valor dado, eliminando las frecuencias más altas </p>

<p>  4000 hertz </p>
<p> p1 >> pluck (P [: 8], dur = 1/2, lpf = 400) </p>

<p>  Con el cambio de resonancia como un linvar </p>
<p> p1 >> pluck (P [: 8], dur = 1/2, lpf = linvar ([500,4000], [8,0]), lpr = linvar ([0.1,1], 12)) </p>


                                <h4>  pan </h4>
<p>  Panoramización, donde -1 está muy a la izquierda, 1 está muy a la derecha (por defecto es 0) </p>

<h4>  rate </h4>
<p>  Variable keyword used for misc. cambios a una señal. P.ej. Velocidad de reproducción del reproductor de muestra (predeterminado en 1) </p>

                            
<h4> room  </h4> 
<p> Palabra clave del título: sala, palabra clave (es) de atributo: mix </p>

<p>  El argumento de la room especifica el tamaño de la room  </p>
<p> d1 >> play ("x-o-", room  = 0.5) </p>

<p>  Mix es la mezcla seca / húmeda de reverberación o la cantidad de reverberación mezclada con la fuente. 1 es todo reverberación, 0 no es reverberación en absoluto. (Por defecto 0.1) </p>
                                
<p> d1 >> play ("x-o-", sala = 0.5, mix = .5) </p>


<h4>sample </h4>
<p>  Palabra clave especial para reproducciones  de sample; selecciona otro archivo de audio del banco de samples para un reproductor de sample . </p>


<h4> slide  </h4> 
<p> - Slide to To Slides 'el valor de frecuencia de una señal a frecuencia * (diapositiva + 1) durante la duración de una nota (por defecto es 0) </p>

<p> p1 >> desplume (P [: 8], dur = 1/2, deslizamiento = 1) </p>

<p> p1 >> desplume (P [: 8], dur = 1/2, deslizamiento = 12) </p>

<p> p1 >> pluck (P [: 8], dur = 1/2, slide = var ([0, -1], [12,4])) </p>

<h4> sus  </h4>
                                <p>  Sustain (por defecto es `dur`) </p>


<h4> vib - Vibrato </h4>
<p> Vibrato - Palabra clave del título: vib, Palabra clave del atributo (s): Vibrato (por defecto es 0) </p>

<p> p1 >> pluck (P [: 8], dur = 1/2, vib = 12) </p>

<p> Con el atributo secundario, vibdepth (predeterminado 0.2) </p>
<p> p1 >> pluck (P [: 8], dur = 1/2, vib = 12, vibdepth = 0.5) </p>

                                    
                                    
								
								</div>
								
								</div>
								
								</div>
								

				<div class="bb-item" id="item8">
						<div class="content">
							<div class="scroller">
								<h2>Patrones</h2>
                                
                                <p> Usando Patrones


<p>  Player Objects utiliza listas de Python, conocidas más comúnmente como matrices en otros idiomas,</p>
<p>  para secuenciar ellos mismos. Ya has usado estos anteriormente, pero no son exactamente </p>
<p>  flexible para la manipulación. Por ejemplo, intente multiplicar una lista por dos como esa: </p>

<p> print([1, 2, 3] * 2) </p>

<p> ¿El resultado es lo que esperabas? </p>

<p>  FoxDot usa un tipo de contenedor llamado 'Patrón' para ayudar a resolver este problema. </p>
<p>  Actúan como listas regulares pero cualquier operación matemática realizada en él se realiza para cada elemento </p>
<p> en la lista y hecho así en pares si se usa un segundo patrón. Se crea un patrón básico como </p>
<p>  lo harías con una lista normal o tupla, pero con una 'P' precediéndola. </p>

<p> print(P [1,2,3] * 2) </p>

<p> print(P [1,2,3] + 100) </p>

<p>  En esta operación, la salida consiste en todas las combinaciones de los dos patrones, es decir </p>
<p> [1 + 3, 2 + 4, 3 + 3, 1 + 4, 2 + 3, 3 + 4] </p>
<p> print(P [1,2,3] + [3,4]) </p>

                                <p>  La sintaxis de corte también funciona </p>
                                
<p> print(P [: 8]) </p>
<p> print(P [0,1,2,3: 20]) </p>

<p> Pruebe con otros operadores matemáticos y vea qué resultados obtiene. </p>
<p> print(P [1,2,3] * (1,2)) </p>

<p> Los objetos de patrón también encartan automáticamente cualquier lista anidada </p>

<p> Lista normal: </p>
<p> para n en [0,1,2, [3,4], 5]:
    print(n) </p>

<p>  Patrón
para n en P [0,1,2, [3,4], 5]:
    print(n) </p>
  

  
<p> Use PGroups si desea evitar este comportamiento. Estos pueden ser implícitamente 
<p> especificado como tuplas en Patrones: 
para n en P [0,1,2, (3,4)]:
    print(n) </p>

<p> print(P (0,2,4) + 2) </p>

<p>  En Python, puede generar un rango de enteros con el rango de sintaxis (inicio, finalización, paso). </p>
<p>  Por defecto, start es 0 y el paso es 1. </p>
<p> print(rango (10)) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] </p>

<p>  Puede usar PRange (inicio, parada, paso) para crear un objeto Pattern con los valores equivalentes: </p>
<p> print (PRange (10)) # P [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] </p>

<p>  P [0, 2, 2, 6, 4, 10, 6, 14, 8, 18] </p>
<p>  [0 * 1, 1 * 2, 2 * 1, 3 * 2, 4 * 1, 5 * 2, 6 * 1, 7 * 2, 8 * 1 ...] </p>
<p> print (PRange (10) * [1, 2]) # Comportamiento de la clase de patrón</p>

<p>   Agregar una lista (o Patrón) a un Patrón agregará los valores de elementos a la otra donde las listas de Python se concatonated. </p>
<p> print(PRange (10) + [0,10])
</p>
								
								</div>
								
								</div>
								
								</div>
								
												<div class="bb-item" id="item9">
						<div class="content">
							<div class="scroller">
								<h2> Generador de patrones</h2>


                                <p>  Patrones de referencia de generadores </p>


<p>  Hay varias otras clases de patrones en FoxDot que te ayudan a generar matrices de números pero también a comportarse </p>
                                <p>de la misma manera que el Patrón base. Para ver qué Patrones existen y probarlos, ejecuta </p>
                                <p> print(clases (Patterns.Sequences)) </p>

<h4>PEuclid </h4>
                                <p> PEuclid (n, k) </p>
<p> Devuelve el ritmo euclidiano que distribuye 'n' pulsos sobre 'k' pasos lo más uniformemente posible. </p> 
                                <p> 3 pulsos en 8 pasos </p>
                                <p> print(PEuclid (3, 8)) </p> 

<h4> PDur </h4>
                                <p>  PDur (n, k, start = 0, dur = 0.25) </p>
<p>  Devuelve las duraciones reales basadas en ritmos euclidianos (ver PEuclid) donde dur es la longitud de cada paso. </p> 
                                <p> Spreads 'n' pulsos sobre 'k' pasos lo más uniformemente posible </p> 

                                <p> print(PDur (3,8)) # P [0.75, 0.75, 0.5] </p> 

                                <p> print(PDur (5,8)) </p> 

                                <p>  Da una lista de 3 dur, se abre con una lista de 5 dur </p>
                                <p> print(PDur ([3,5], 8)) </p> 

                                <p> d1 >> play ("x", dur = PDur (5,8)) </p> 


<h4> PIndex </h4>
                                <p> Devuelve el índice al que se accede </p> 

                                <p> print(PIndex ()) </p> 
                                <p> print(PIndex () * 4) </p> 

<h4>  PSine </h4>
                                <p>  PSine (n = 16) </p> 
                                <p>  Devuelve valores de un ciclo de onda sinusoidal dividida en 'n' partes </p> 

                                <p>  Split en 5 partes </p> 
                                <p> print(PSine (5)) </p> 

                                <p>  Split en 10 </p> 
                                <p> print(PSine (10)) </p> 


<h4>  PTri </h4>
                                <p>  PTri (inicio, parada = Ninguno, paso = Ninguno) </p> 
<p>  Devuelve un patrón equivalente a `Patrón (rango (inicio, parada, paso)) con su forma invertida añadida. </p> 
                                <p>  Piénsalo como un ángulo "Tri". </p> 

                                <p>  Hasta 5 y luego hasta 1 </p>
                                <p> print(PTri (5)) </p> 

                                <p>  Hasta 8 y luego hasta 1 </p> 
<p> print(PTri (8)) </p>

                                <p>  De 3 a 10, luego a 4 </p> 
                                <p> print(PTri (3,10)) </p> 

                                <p>  De 3 a 30, por 2, luego a 4 </p> 
                                <p> print(PTri (3,20,2)) </p> 

                                <p>  Hasta 4, luego hasta 1, luego hasta 8, luego hasta 1 </p> 
                                <p> print(PTri ([4,8])) </p>

                                <p> p1 >> pluck (PTri (5), scale = Scale.default.pentatonic) </p> 

                                <p>  Igual que </p> 
<p> p1 >> pluck (PRange (5) | PRange (5,0, -1), scale = Scale.default.pe</p> 
								
								</div>
								
								</div>
								
								</div>

	
												<div class="bb-item" id="item10">
						<div class="content">
							<div class="scroller">
								<h2> Escalas</h2>
				

<p> Por defecto, los objetos del reproductor usan la escala C mayor.
</p>
<p> Estos pueden cambiarse usando los argumentos de la palabra clave 'scale' y 'root'.
</p>
<p>Las escalas se pueden definir como una matriz de semitonos, de modo que la escala Mayor es [0,2,4,5,7,9,11]

</p><p> o una de las escalas predefinidas del módulo Escala, p. Scale.minor.
</p>
<p> Root se refiere a la tónica de la escala; 0 es C, 1 es C #, 2 es D y así sucesivamente.
</p>
<p>La escala predeterminada se puede cambiar de forma que cualquier reproductor que no use una escala específica se actualice.

</p>

<p>Esto se hace usando la sintaxis a continuación (cada línea es técnicamente equivalente):
</p>
Scale.default.set ("principal")
Scale.default.set (Scale.major)
Scale.default.set ([0,2,4,5,7,9,11])

<p> O lo mismo, pero menor:

</p>
Scale.default.set ("menor")
Scale.default.set (Scale.minor)
Scale.default.set ([0,2,3,5,7,10])

<p> Esto es lo mismo para la raíz:
</p>
Root.default.set (1)
Root.default.set ("C #")

<p> O:

</p>

Root.default.set (2)
Root.default.set ("D")

<p>Para ver una lista de todas las escalas, use
</p>
print (Scale.names ())

<p> Puede cambiar la escala utilizada por un reproductor usando la palabra clave 'escala'
</p>
p1 >> pads ([0,1,2], scale = Scale.minor)

<p> Del mismo modo, puede cambiar los reproductores de la nota raíz utilizando la palabra clave raíz </p>
<p> y el objeto Root.default </p>

<p> p1 >> pads ([0,1,2], scale = Scale.minor, root = 2)

</p>
								
								</div>
								
								</div>
								
								</div>
									
												<div class="bb-item" id="item11">
						<div class="content">
							<div class="scroller">
								<h2> Variables</h2>
                                
                                <p> Uso de Vars </p> 


<p>  A TimeVar es una abreviatura de "Variable dependiente del tiempo" y es una característica clave de FoxDot. </p> 
                                <p> A TimeVar tiene una serie de valores que cambia entre una cantidad predefinida de tiempos </p> 
<p>  y se crea utilizando un objeto var con la sintaxis var ([list_of_values], [list_of_durations]). </p> 

                                <p>  Genera el patrón: 0,0,0,0,3,3,3,3 ... </p> 
                                <p> a = var ([0,3], 4) # La duración puede ser de valor único </p> 
                                <p> print (int (Clock.now ()), a) # 'a' initally tiene un valor de 0 </p> 
                                <p>  >>> 0, 0 </p> 

                                <p> print (int (Clock.now ()), a) # Después de 4 tiempos, el valor cambia a 3 </p>
                                <p>  >>> 4, 3 </p> 

<P>print (int (Clock.now ()), a) # Después de otros 4 tiempos, el valor cambia a 0 </P>
                                <p>  >>> 8, 0 </p> 

                                <p>  Duración también puede ser una lista </p> 
                                <p> a = var ([0,3], [4,2]) </p> 
                                <p> print (int (Clock.now ()), a) </p> 

<p>  Cuando se usa un TimeVar en una operación matemática, los valores que afecta también se convierten en TimeVars </p> 
<p>  que cambian de estado cuando el TimeVar original cambia de estado; esto incluso se puede usar con patrones:</p> 
                                <p> a = var ([0,3], 4) </p> 
                                <p> print (int (Clock.now ()), a + 5) # Cuando el tiempo es 0, a es 5 </p>
                                <p>  >>> 5 </p>

                                <p> print (int (Clock.now ()), a + 5) </p>
                                <p> Cuando el tiempo es 4, a es 8 </p> 
                                <p>  >>> 8 </p> 

                                <p> b = PRange (4) + a </p> 
                                <p> print (int (Clock.now ()), b) </p> 
                                <p>  Después de 8 beats, el valor cambia a 0 </p>
                                <p>  >>> P [0, 1, 2, 3] </p> 

                                <p> print (int (Clock.now ()), b) # Después de 12 beats, el valor cambia a 3 </p> 
                                <p>  >>> P [3, 4, 5, 6] </p> 

<p>  Use 'var' con sus objetos Player para crear progresiones de acordes. </p>
                                <p> a = var ([0,4,5,3], 4) </p> 
                                <p> b1 >> bass (a, dur = PDur (3,8)) </p> 
                                <p> p1 >> pads (a + (0,2), dur = PDur (7,16)) </p> 

                                <p>  Puede agregar una 'var' a un objeto Player o a una var. </p> 
                                <p> b1 >> bajo (a, dur = PDur (3,8)) + var ([0,1], [3,1]) </p> 

                                <p> b = a + var ([0,10], 8) </p> 

                                <p> print (int (Clock.now ()), (a, b)) </p> 

                                <p>  La actualización de los valores de una 'var' lo actualizará en cualquier otro lugar </p> 
                                <p> a.update ([1,4], 8) </p> 

                                <p> print (int (Clock.now ()), (a, b)) </p> 

                                <p>  Vars pueden ser nombrados ... </p> 
                                <p> var.chords = var ([0,4,5,4], 4)  </p> 

                                <p>  Y usado más tarde </p> 
                                <p> b1 >> pluck (var.chords) </p> 

                                <p>  Cualquier jugador que use la var nombrada se actualizará </p> 
                                <p> var.chords = var ([0,1,5,3], 4) </p> 

                                <p>  También puede usar un 'linvar' que cambia sus valores gradualmente a lo largo del tiempo </p> 
                                <p>  Cambiar el valor de 0 a 1 en 16 tiempos </p> 
                                <p> c = linvar ([0,1], 16) </p> 

                                <p>  Ejecutar esto varias veces para ver los cambios que suceden </p> 
                                <p> print (int (Clock.now ()), c) </p> 

                                <p>  Cambiar el amplificador basado en ese linvar </p> 
                                <p> p1 >> pads (a, amp = c) </p> 

<p>  a 'Pvar' es una 'var' que puede almacenar patrones (en oposición a decir enteros) </p>
<p> d = Pvar ([P [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], P [0, 1, 2, 3, 4, 5, 4, 3, 2, 1]], 8) </p>

<p> print (int (Clock.now ()), d) </p>

<p> p1 >> pads (a, amp = c, dur = 1/4) + d </p>

<p> Cambiar la escala cada 16 tiempos </p>
<p> Scale.default = Pvar ([Scale.major, Scale.minor], 16)
                                </p>
								</div>
								
								</div>
								
								</div>
								
				</div>
				
				
				
				
				<nav>
					<span id="bb-nav-prev">&larr;</span>
					<span id="bb-nav-next">&rarr;</span>
				</nav>

				<span id="tblcontents" class="menu-button">Table of Contents</span>

			</div>
				
		</div><!-- /container -->
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
		<script src="js/jquery.mousewheel.js"></script>
		<script src="js/jquery.jscrollpane.min.js"></script>
		<script src="js/jquerypp.custom.js"></script>
		<script src="js/jquery.bookblock.js"></script>
		<script src="js/page.js"></script>
		<script>
			$(function() {

				Page.init();

			});
		</script>
	</body>
</html>
