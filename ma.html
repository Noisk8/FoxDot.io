<!DOCTYPE html>

<html lang="en" class="">

<head>

      <meta charset="UTF-8"/>
      <title> Manipulaci√≥n Algoritmica</title>
      <meta name="FoxDot | Livecoding"/>
      <link rel="stylesheet" type="text/css" href="css/..."/>
      <link rel="stylesheet" type="text/css" href="css/..."/>
    <link rel="stylesheet" type="text/css" href="css/normalize.css" />
		<link rel="stylesheet" type="text/css" href="css/demo.css" />
		<link rel="stylesheet" type="text/css" href="css/style-tsula.css" />

      <script> </script>

</head>
    
     <div class="margenuno">
      <heaheader  >
        <a href="index.html" ><h1> ü¶ä</h1></a>
      
          <h2 >Foxdot / Renardo </h2>
  
  
  </heaheader>
    </div>
<body class="fondo">
    
<div class="margenuno">
  <h2> Manipulaci√≥n algoritmica</h2>
				<p>Una de las cosas buenas de la codificaci√≥n en vivo es que puede programar eventos para que ocurran, o se repitan, en el futuro. Esto le permite continuar codificando mientras se llaman funciones repetidas y a√±adir variedad a su m√∫sica. Esta secci√≥n es un an√°lisis detallado de c√≥mo se implementa cada m√©todo del Reproductor y c√≥mo puede combinar varias instancias del mismo para crear m√∫sica compleja a partir de patrones simples.
             </p>
                                 <hr style= "border-color: #4e7c5c; width:90%"> 
                                <h3>Fundamentos</h3>
                                <p>Primero veamos un ejemplo simple que invierte una secuencia cada 8 latidos:</p>
                                <p><code>p1 >> pluck([0, 1, 2, 3, 4, 5, 6, 7]).every(8, "reverse")</code></p>
                                <p>El primer argumento es el n√∫mero de pulsaciones entre cada llamada de un m√©todo y el segundo es el nombre del m√©todo en s√≠ como una cadena. La raz√≥n para usar el nombre de cadena del m√©todo en lugar de una funci√≥n es que Python puede comprobar si el m√©todo es v√°lido usando la funci√≥n getattr y generar un error si no lo es. Ejecutando el c√≥digo <code>print(getattr(p1, "reverse"))</code> le dar√° algo similar al m√©todo bound Player.reverse of p1 - pluck. Lo que entonces sucede, en esencia, es que el reloj de programaci√≥n ejecuta <code>getattr(p1, "reverse").__call__()</code> cada 8 tiempos.</p>
                                
                                <p>Puede utilizar una lista de duraciones para programar llamadas a m√©todos a intervalos irregulares:</p>
                                
                                <p><code>p1 >> pluck([0, 1, 2, 3, 4, 5, 6, 7]).every([6, 2], "reverse")</code></p>
                                
                                <p>El c√≥digo de arriba llamar√° al m√©todo inverso despu√©s de 6 latidos, luego 2 latidos despu√©s de eso, luego otra vez 6 latidos despu√©s de esa llamada, repitiendo esto hasta que se detenga. Tambi√©n puede utilizar un objeto Pattern o PatternGenerator como PRand para llamar m√©todos a veces no predeterminados:</p>
                                <p><code>p1 >> pluck([0, 1, 2, 3, 4, 5, 6, 7]).every(PRand([2, 4, 8]), "reverse")</code></p>
                                <p>Si intenta especificar varias llamadas del mismo m√©todo, ver√° que s√≥lo se programa la √∫ltima llamada actualizada. Si desea utilizar m√°s de una llamada repetida al mismo m√©todo, puede utilizar la palabra clave de identificaci√≥n y darle un nombre o n√∫mero para diferenciarla:</p>
                                <p><code># Llama "reversa" cada 8 latidos *y* cada 5 latidos</code></p>
                                <p><code>d1 >> pluck([0, 1, 2, 3, 4, 5, 6, 7]).every(8, "reverse").every(5, "reverse", ident=1)</code></p>
                                
                                
                                <p>Los m√©todos de los jugadores que pueden ser usados con cada uno efectivamente son reversa, rotaci√≥n, barajar, saltar y tartamudear.
                                La palabra clave del ciclo</p>
                                <p><code>La palabra clave del ciclo</code></p>
                                
                                <p>A veces puede ser √∫til programar un m√©todo para el mismo punto en un ciclo de N-tiempos, por ejemplo, tartamudear el sonido en el 6¬∫ tiempo de cada ciclo de 8 tiempos. Puede hacerlo simplemente especificando la longitud del ciclo como argumento de palabra clave:</p>
                                
                                <p><code>d1 >> play("x-o-").every(6, "stutter", cycle=8)</code></p>
                                <p>En lugar de llamar tartamudeo a cada 6 latidos, se llama cada 8 latidos (el tama√±o del ciclo), pero compensado por 6 latidos.
                                El m√©todo del tartamudeo en profundidad</p>
                                
                                <p>Uno de los m√©todos m√°s √∫tiles que se puede llamar usando cada uno es el m√©todo del tartamudeo. Reproduce el √∫ltimo evento enviado a SuperCollider varias veces a lo largo de una duraci√≥n especificada. Tambi√©n puede especificar atributos/efectos para adjuntar a los eventos como pan o shape usando argumentos de palabras clave.</p>
                                
                                <p>Puede especificar el n√∫mero de veces que un evento tartamudea simplemente proporcionando un n√∫mero entero a cada llamada siguiendo el nombre del m√©todo como una cadena. El valor por defecto es 2, lo que significa que escuchar√° 1 evento adicional - 2 menos el evento que ya se est√° reproduciendo. Usando un valor de 4 se reproducir√°n 3 eventos extra (ya tienes la idea). Por defecto, los eventos ser√°n tartamudeados a lo largo de la duraci√≥n del evento que est√° tartamudeando, pero tambi√©n puede tartamudear los eventos a lo largo de un per√≠odo de tiempo determinado mediante el suministro de una palabra clave dur:</p>
                                
                                <p><code># Reproducir el evento 4 veces cada 6 latidos a trav√©s de 1/2 latido</code></p>
                                <p><code>d1 >> play("x-o-", dur=1/2).every(6, "stutter", 4)</code></p>
                                <p><code># Juega el evento 4 veces cada 6 latidos a trav√©s de 3 latidos</code></p>
                                <p><code>d1 >> play("x-o-", dur=1/2).every(6, "stutter", 4, dur=3)</code></p>
                                <p><code>Tambi√©n puede especificar el n√∫mero de eventos a tartamudear usando la palabra clave 'n</code></p>
                                <p><code>d1 >> play("x-o-", dur=1/2).every(6, "stutter", dur=3, n=4)</code></p>
                                
                                <p>As√≠ como usted proporciona argumentos de palabras clave para controlar el sonido de sus sintetizadores, puede hacer lo mismo con el tartamudeo para controlar el sonido que se est√° reproduciendo. Estos pueden ser una lista o patr√≥n de valores que se dan a cada evento tartamudeado a su vez, es decir, no jugado todos a la vez:</p>
                                
                                
                                <p><code># Tartamudea 8 veces con el aumento de la velocidad de reproducci√≥n</code></p>
                                <p><code>d1 >> play("x-o-").every(4, "stutter", 8, rate=[1,2,3,4,5,6,7,8])</code></p>
                                 <p><code># Tartamudeo 4 veces con paneo alternado y mayor velocidad</code></p>
                                <p><code>d1 >> play("x-o-").every(4, "stutter", 4, dur=3, pan=[-1, 1], rate=2)</code></p>
                                 <p><code>#Todav√≠a puedes usar tuplas / PGroups para a√±adir efectos simult√°neos</code></p>
                                <p><code>d1 >> play("x-o-").every(4, "stutter", 4, dur=1, pan=(-1,1), rate=(4, 1/2))</code></p>
                                <p>Tenga en cuenta que cuando se utiliza una lista de valores, s√≥lo se utilizar√°n los primeros n valores (donde n es el n√∫mero de veces que se tartamudea).</p>
                                 <hr style= "border-color: #4e7c5c; width:90%"> 
                                <h3>Uso de m√©todos de patrones</h3>
                                
                                <p>Adem√°s de revertir, rotar, barajar, saltar y tartamudear, tambi√©n puede programar cualquier m√©todo que pertenezca a la clase Patr√≥n para que se llame en cualquier atributo de un reproductor. El comportamiento es ligeramente diferente a cuando se programan los m√©todos de los jugadores en el sentido de que en lugar de ser llamado cada n beats, es llamado y luego desllamado so-to-speak. Probablemente es mejor demostrarlo con un ejemplo:</p>
                                
                                <p><code>Llama al m√©todo "trim" en el atributo de grado</code></p>
                                <p><code>d1 >> play("x-o-").every(4, "trim", 3)</code></p>
                                
                                <p>El patr√≥n "x-o-" se recorta a s√≥lo "x-o" despu√©s de 4 tiempos y luego vuelve a "x-o-" de nuevo despu√©s de los siguientes 4 tiempos. Por defecto, el m√©todo se llama atributo grado (que es pitch para la mayor√≠a de los sintetizadores y la cadena de caracteres para el sintetizador de reproducci√≥n) - puede especificar un atributo diferente anteponiendo al nombre del m√©todo el nombre del atributo y luego un ":</p>
                                
                                
                                <p><code># Trim the octave pattern to 3 every 4 beats</code></p>
                                <p><code>p1 >> pluck([0,1,2,3], oct=[4,5,6,7]).every(4, "oct.trim", 3)</code></p>
                                
                                <p>Los argumentos que se proporcionar√≠an al m√©todo del patr√≥n se dan siguiendo el nombre del m√©todo. Por ejemplo, el m√©todo de patr√≥n offadd, que superpone un patr√≥n consigo mismo pero con un valor a√±adido y retrasado por una duraci√≥n, toma 2 argumentos; el valor a a√±adir y el tiempo de retardo (por defecto es 0,5). Aqu√≠ hay algunos ejemplos de c√≥mo usarlo con cada una de las aplicaciones:</p>
                                
                                <p><code># Toca una nota 2 pasos m√°s alto retrasado 1/2 latido</code></p>
                                <p><code>p1 >> pasha([0, 4], dur=[3/4, 3/4, 1/2]).every(3, "offadd", </code></p>
                                <p><code># Toca una nota 4 pasos m√°s alto retrasado 3/4 de un ritmo</code></p>
                                <p><code>p1 >> pasha ([0,1,3,4], dur=1/2).every(5, "offadd", 4, 3/4)</code></p>
                                
                                <p>Puede utilizar cualquier m√©todo de la clase Patr√≥n, que puede ver ejecutando help(Pattern) o mirando las descripciones en profundidad.</p>
                                
</div>
</body>
    
    <div class="margenuno"> <a href="mdr.html"> Atras </a>  <a  href="eyf.html">siguiente </a> </div>

<footer>
</footer>